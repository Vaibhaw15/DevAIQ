[
  {
    "questionText": "Given a `HashMap<String, Integer> map = new HashMap<>();`, what is the time complexity for getting an element if `hashCode()` and `equals()` are poorly implemented for the key objects?",
    "correctAnswer": "O(n)",
    "explanation": "If `hashCode()` is poorly implemented, many keys might map to the same bucket, essentially turning the hash map into a linked list in the worst case, leading to O(n) for get and put operations. If `equals()` is also poor, it further exacerbates collision resolution.",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n)",
      "O(n log n)"
    ]
  },
  {
    "questionText": "What is the primary difference between `ReentrantLock` and `synchronized` keyword in Java concurrency?",
    "correctAnswer": "`ReentrantLock` offers more flexible and fine-grained control over locking (e.g., timed lock attempts, interruptible locks, fairness).",
    "explanation": "`synchronized` is simpler but less flexible. `ReentrantLock` provides explicit locking mechanisms with features like `tryLock()`, `lockInterruptibly()`, and configurable fairness, which `synchronized` does not.",
    "options": [
      "`synchronized` prevents deadlocks, `ReentrantLock` does not.",
      "`ReentrantLock` is only for static methods, `synchronized` for instance methods.",
      "`ReentrantLock` offers more flexible and fine-grained control over locking (e.g., timed lock attempts, interruptible locks, fairness).",
      "`synchronized` guarantees fairness, `ReentrantLock` does not."
    ]
  },
  {
    "questionText": "Consider `CompletableFuture`. Which method would you use to apply a function to the result of this `CompletableFuture` when it completes, returning a new `CompletableFuture` for the transformed result?",
    "correctAnswer": "`thenApply()`",
    "explanation": "`thenApply()` is used to transform the result of a `CompletableFuture` by applying a function to it, returning a new `CompletableFuture` that holds the transformed value. `thenAccept()` consumes the result, `thenCompose()` is for chaining dependent `CompletableFuture`s.",
    "options": [
      "`thenRun()`",
      "`thenAccept()`",
      "`thenApply()`",
      "`thenCompose()`"
    ]
  },
  {
    "questionText": "Which Java 8 `Stream` operation is typically used to flatten a stream of collections into a single stream of elements?",
    "correctAnswer": "`flatMap()`",
    "explanation": "`flatMap()` is used when you have a stream of streams (or stream of collections) and you want to 'flatten' them into a single stream.",
    "options": [
      "`map()`",
      "`filter()`",
      "`collect()`",
      "`flatMap()`"
    ]
  },
  {
    "questionText": "What is `ThreadLocal` in Java, and why is it used?",
    "correctAnswer": "It provides thread-local variables, meaning each thread that accesses it has its own independent copy of the variable.",
    "explanation": "`ThreadLocal` variables are used to avoid synchronization issues by giving each thread its own copy of a variable, preventing shared state and potential race conditions.",
    "options": [
      "It is a thread-safe list of threads.",
      "It provides thread-local variables, meaning each thread that accesses it has its own independent copy of the variable.",
      "It is used to explicitly assign a thread to a specific CPU core.",
      "It creates a new thread for each method call."
    ]
  },
  {
    "questionText": "What is the consequence of throwing an `Error` (e.g., `OutOfMemoryError`) from a Java application?",
    "correctAnswer": "It indicates a serious problem that the application generally cannot recover from, leading to JVM termination or instability.",
    "explanation": "`Error`s represent serious runtime problems, typically beyond the control of the application, such as JVM internal errors or resource exhaustion. Attempting to catch and recover from them is usually futile and discouraged.",
    "options": [
      "The `finally` block will not be executed.",
      "The application will always crash without any log messages.",
      "It indicates a serious problem that the application generally cannot recover from, leading to JVM termination or instability.",
      "It triggers a garbage collection cycle."
    ]
  },
  {
    "questionText": "What is `PhantomReference` used for in Java's Reference Objects?",
    "correctAnswer": "To schedule post-mortem cleanup actions for an object when it becomes phantom reachable.",
    "explanation": "`PhantomReference` objects are enqueued in a `ReferenceQueue` only after the object has been finalized and is otherwise unreachable, making them useful for critical cleanup operations where resources must be released precisely at the moment of garbage collection.",
    "options": [
      "To detect memory leaks.",
      "To allow garbage collection of an object only if memory is low.",
      "To schedule post-mortem cleanup actions for an object when it becomes phantom reachable.",
      "To prevent an object from ever being garbage collected."
    ]
  },
  {
    "questionText": "Explain the **`happens-before` guarantee** in the Java Memory Model.",
    "correctAnswer": "It defines a partial ordering of all actions in a program and dictates when writes made by one thread are visible to another.",
    "explanation": "The `happens-before` relationship ensures memory visibility and ordering constraints. For instance, an unlock on a monitor `happens-before` a subsequent lock on the same monitor. This helps prevent data races and ensures consistency.",
    "options": [
      "It ensures that all threads execute in a predetermined order.",
      "It guarantees that a volatile write will always occur before a synchronized block.",
      "It defines a partial ordering of all actions in a program and dictates when writes made by one thread are visible to another.",
      "It forces the JVM to execute all instructions in a single CPU core."
    ]
  },
  {
    "questionText": "What is the purpose of the `invoke()` method in Java Reflection, particularly when dealing with `private` methods?",
    "correctAnswer": "To dynamically call a method on an object, even if it's private, after setting `setAccessible(true)`.",
    "explanation": "Reflection allows invoking methods dynamically. For non-public methods, you must call `method.setAccessible(true)` before `invoke()` to bypass standard access checks.",
    "options": [
      "To get the signature of a method.",
      "To check if a method exists in a class.",
      "To dynamically call a method on an object, even if it's private, after setting `setAccessible(true)`.",
      "To declare a new method at runtime."
    ]
  },
  {
    "questionText": "What is **Type Erasure**'s impact on overloaded methods with generic arguments?",
    "correctAnswer": "Methods overloaded with generic parameters that erase to the same raw type will result in a compile-time error.",
    "explanation": "Due to type erasure, `List<String>` and `List<Integer>` both become `List` at runtime. If you try to overload methods with these, it's a signature clash after erasure, leading to a compile-time error.",
    "options": [
      "It has no impact, as overloading is resolved at runtime.",
      "Methods overloaded with generic parameters that erase to the same raw type will result in a compile-time error.",
      "It allows overloading methods based on the erased types.",
      "It causes a runtime `ClassCastException` for such overloads."
    ]
  },
  {
    "questionText": "Explain **Stale Data** in a multi-threaded context without proper synchronization.",
    "correctAnswer": "When one thread reads a variable's old value from its local cache, while another thread has already updated it in main memory.",
    "explanation": "Without proper synchronization (like `volatile` or `synchronized`), a thread might see an outdated value of a variable that has been modified by another thread, because it's reading from its CPU cache instead of main memory.",
    "options": [
      "When a thread attempts to access a variable that has been garbage collected.",
      "When one thread reads a variable's old value from its local cache, while another thread has already updated it in main memory.",
      "When a variable is declared as `static`.",
      "When data is written to a file that no longer exists."
    ]
  },
  {
    "questionText": "What is a **`CyclicBarrier`** used for in Java concurrency?",
    "correctAnswer": "To synchronize multiple threads at a common barrier point, allowing them to wait until all threads have reached that point before proceeding.",
    "explanation": "`CyclicBarrier` is a synchronization aid that allows a set of threads to wait for each other to reach a common barrier point. It's 'cyclic' because the barrier can be reused once the waiting threads are released.",
    "options": [
      "To prevent deadlocks between two threads.",
      "To allow only one thread at a time to access a critical section.",
      "To synchronize multiple threads at a common barrier point, allowing them to wait until all threads have reached that point before proceeding.",
      "To schedule recurring tasks at fixed intervals."
    ]
  },
  {
    "questionText": "What is a **`CountDownLatch`** used for in Java concurrency?",
    "correctAnswer": "To cause one or more threads to wait until a set of operations being performed by other threads completes.",
    "explanation": "`CountDownLatch` is a synchronization aid that allows one or more threads to wait until a set of operations (tracked by a counter) in other threads completes. The counter decreases, and when it reaches zero, waiting threads are released.",
    "options": [
      "To repeatedly wait for multiple threads to reach a common point.",
      "To cause one or more threads to wait until a set of operations being performed by other threads completes.",
      "To implement a producer-consumer queue.",
      "To limit the number of active threads."
    ]
  },
  {
    "questionText": "In the context of `HashMap`, what is the significance of the **load factor**?",
    "correctAnswer": "It determines the threshold for resizing the hash table (rehashing) to maintain performance.",
    "explanation": "The load factor dictates when the `HashMap` capacity should be increased. When `(current_size / capacity)` exceeds the load factor, the map rehashes to a larger capacity to reduce collisions and maintain O(1) average-case performance.",
    "options": [
      "It specifies the maximum number of elements the `HashMap` can store.",
      "It defines the initial number of buckets in the hash table.",
      "It determines the threshold for resizing the hash table (rehashing) to maintain performance.",
      "It is a multiplier for the hash code calculation."
    ]
  },
  {
    "questionText": "What is the primary purpose of **`WeakHashMap`**?",
    "correctAnswer": "Its keys are held by weak references, allowing entries to be garbage collected if their keys are no longer strongly referenced elsewhere.",
    "explanation": "`WeakHashMap` is useful for caching or mapping temporary objects. If a key object is only referenced by the `WeakHashMap`, it becomes eligible for garbage collection, and its entry is removed from the map.",
    "options": [
      "It provides faster access than `HashMap`.",
      "Its values are held by weak references, making them eligible for garbage collection.",
      "Its keys are held by weak references, allowing entries to be garbage collected if their keys are no longer strongly referenced elsewhere.",
      "It is a thread-safe version of `HashMap`."
    ]
  },
  {
    "questionText": "Explain the concept of **Covariant Return Types** with an example.",
    "correctAnswer": "A method in a subclass can return a subtype of the return type of the method it overrides in the superclass (e.g., `Object`'s `clone()` returning `MyClass` in `MyClass`).",
    "explanation": "Introduced in Java 5, it allows overridden methods to return a more specific type than the one in the superclass, improving type safety and readability.",
    "options": [
      "A method can accept arguments of multiple types.",
      "A method can return different types based on input arguments.",
      "A method in a subclass can return a subtype of the return type of the method it overrides in the superclass (e.g., `Object`'s `clone()` returning `MyClass` in `MyClass`).",
      "A method can return `null` if no specific value is available."
    ]
  },
  {
    "questionText": "What is the primary use case for `MethodHandles` compared to traditional Reflection (`java.lang.reflect`)?",
    "correctAnswer": "`MethodHandles` provide a more efficient, type-safe, and flexible alternative for dynamic method invocation, often compiled into bytecode.",
    "explanation": "`MethodHandles` were introduced in Java 7 to offer better performance and more control than `java.lang.reflect`. They operate at a lower level, closer to bytecode, allowing for more optimizations by the JIT compiler.",
    "options": [
      "To access `private` members without `setAccessible(true)`.",
      "To serialize objects more efficiently.",
      "`MethodHandles` provide a more efficient, type-safe, and flexible alternative for dynamic method invocation, often compiled into bytecode.",
      "To generate bytecode at runtime without a compiler."
    ]
  },
  {
    "questionText": "What is a **`ForkJoinPool`** and when is it typically used?",
    "correctAnswer": "An `ExecutorService` for executing `ForkJoinTask`s, particularly suited for work-stealing algorithms in parallel recursive computations.",
    "explanation": "`ForkJoinPool` efficiently handles tasks that can be broken down into smaller subtasks (fork-join pattern), optimizing resource utilization through a work-stealing algorithm where idle threads steal tasks from busy ones.",
    "options": [
      "A pool of database connections.",
      "A fixed-size thread pool for short-lived tasks.",
      "An `ExecutorService` for executing `ForkJoinTask`s, particularly suited for work-stealing algorithms in parallel recursive computations.",
      "A mechanism for creating lightweight processes."
    ]
  },
  {
    "questionText": "Explain the concept of **Strong vs. Weak Encapsulation** in relation to Java modules (JPMS).",
    "correctAnswer": "Strong encapsulation prevents reflective access to encapsulated types from outside the module unless explicitly exported or opened; weak encapsulation only warns about such access.",
    "explanation": "JPMS enforces strong encapsulation by default, meaning non-exported/non-opened packages are not accessible, even via reflection. Weak encapsulation (default in Java 9+ for classpath) allows reflective access with warnings.",
    "options": [
      "Strong encapsulation uses `private` fields, weak encapsulation uses `protected` fields.",
      "Strong encapsulation is for static methods, weak encapsulation for instance methods.",
      "Strong encapsulation prevents reflective access to encapsulated types from outside the module unless explicitly exported or opened; weak encapsulation only warns about such access.",
      "Strong encapsulation applies to interfaces, weak encapsulation to classes."
    ]
  },
  {
    "questionText": "What is a **`Spliterator`** and its primary role in Java 8 Streams?",
    "correctAnswer": "An object for traversing and partitioning elements of a source, designed for parallel processing of streams.",
    "explanation": "`Spliterator` (Splitable Iterator) is a powerful interface for traversing and partitioning elements of a source. It's fundamental to how parallel streams work, allowing sources to be efficiently split for processing by multiple threads.",
    "options": [
      "A special type of `Iterator` for linked lists.",
      "An object for performing sorting operations on streams.",
      "An object for traversing and partitioning elements of a source, designed for parallel processing of streams.",
      "A mechanism to combine multiple streams into one."
    ]
  },
  {
    "questionText": "When might you prefer `BlockingQueue` over a simple `List` with `synchronized` methods for a producer-consumer scenario?",
    "correctAnswer": "When you need built-in thread safety, capacity-boundedness, and blocking operations for full/empty conditions.",
    "explanation": "`BlockingQueue` implementations provide atomic and thread-safe operations with built-in blocking mechanisms (`put()` and `take()`) that automatically handle scenarios where the queue is full (for producers) or empty (for consumers), avoiding busy-waiting and complex manual synchronization.",
    "options": [
      "When you need to store elements in a specific order.",
      "When memory usage is a critical concern.",
      "When you need built-in thread safety, capacity-boundedness, and blocking operations for full/empty conditions.",
      "When random access to elements is frequently required."
    ]
  },
  {
    "questionText": "What is the effect of having a `static` field in a `Serializable` class that is not declared `transient`?",
    "correctAnswer": "Static fields are not part of an object's state and are thus not serialized. Their value will be what's in the class when deserialized.",
    "explanation": "Static fields belong to the class, not to any specific instance. Serialization is about preserving an object's instance state, so static fields are ignored by the serialization mechanism.",
    "options": [
      "A `NotSerializableException` will be thrown.",
      "The static field will be serialized along with the object's instance data.",
      "Static fields are not part of an object's state and are thus not serialized. Their value will be what's in the class when deserialized.",
      "The value of the static field will be reset to its default during deserialization."
    ]
  },
  {
    "questionText": "What is the purpose of a **`StampedLock`** in Java concurrency (Java 8)?",
    "correctAnswer": "It provides optimistic reads, pessimistic read/write locks, and is more flexible than `ReentrantReadWriteLock` for certain scenarios.",
    "explanation": "`StampedLock` offers three modes of locking: exclusive (write), optimistic read, and pessimistic read. Optimistic reads are non-blocking and can be validated later, offering higher concurrency in read-heavy scenarios.",
    "options": [
      "It is a simplified version of `synchronized` for simple locking.",
      "It only supports write locks, but with higher performance.",
      "It provides optimistic reads, pessimistic read/write locks, and is more flexible than `ReentrantReadWriteLock` for certain scenarios.",
      "It is used for locking database rows exclusively."
    ]
  },
  {
    "questionText": "How does `try-with-resources` internally work to ensure resource closure, especially if multiple resources are declared?",
    "correctAnswer": "It generates bytecode that implicitly calls the `close()` method of each `AutoCloseable` resource in reverse order of declaration, adding `suppressed` exceptions if `close()` fails.",
    "explanation": "The compiler adds hidden `finally` blocks that call `close()` on the declared resources. If `close()` throws an exception, it's added as a suppressed exception to the original exception (if any), preserving the primary cause.",
    "options": [
      "It uses a separate thread to monitor and close resources.",
      "It automatically deallocates memory for resources through garbage collection.",
      "It generates bytecode that implicitly calls the `close()` method of each `AutoCloseable` resource in reverse order of declaration, adding `suppressed` exceptions if `close()` fails.",
      "It requires manual `close()` calls within the `try` block."
    ]
  },
  {
    "questionText": "What is a **`VarHandle`** (Java 9+), and what problem does it address better than Reflection or `Unsafe`?",
    "correctAnswer": "A low-level mechanism for dynamic, safe access to fields and array elements, offering better performance and safety than `Unsafe`, and more flexibility than Reflection.",
    "explanation": "`VarHandle` provides a standardized and safer way to perform operations similar to those previously done with `sun.misc.Unsafe` for atomic operations, memory ordering guarantees, and field access, while being more secure and maintainable than `Unsafe` and more powerful than Reflection for low-level memory interactions.",
    "options": [
      "A tool for creating anonymous inner classes at runtime.",
      "A mechanism to generate bytecode directly without writing Java source code.",
      "A low-level mechanism for dynamic, safe access to fields and array elements, offering better performance and safety than `Unsafe`, and more flexibility than Reflection.",
      "A way to define new primitive types."
    ]
  },
  {
    "questionText": "Explain `Double Checked Locking` for Singleton implementation, and why it required `volatile` before Java 5.",
    "correctAnswer": "It's a pattern for lazy initialization with thread safety, requiring `volatile` on the instance variable to prevent instruction reordering that could lead to partially constructed objects being observed.",
    "explanation": "Double-checked locking attempts to avoid the cost of synchronization after the first instance is created. `volatile` was crucial (pre-Java 5) to ensure that the writes involved in constructing the `Singleton` object (allocating memory, initializing fields) were not reordered by the compiler/CPU, making a partially initialized object visible to another thread.",
    "options": [
      "It's a way to create two instances of a singleton for redundancy.",
      "It's a synchronization mechanism for `static` methods only.",
      "It's a pattern for lazy initialization with thread safety, requiring `volatile` on the instance variable to prevent instruction reordering that could lead to partially constructed objects being observed.",
      "It ensures that a singleton is always eagerly initialized."
    ]
  },
  {
    "questionText": "What is **`Method Chaining`** (Fluent API) and what design pattern does it often embody?",
    "correctAnswer": "A design technique where methods return the object itself (or `this`), allowing multiple method calls to be chained together. Often embodies the Builder pattern.",
    "explanation": "Method chaining allows calls like `object.method1().method2().method3()`. This enhances readability and is commonly seen in the Builder pattern, where steps are chained to construct a complex object.",
    "options": [
      "Calling a method inside another method in the same class.",
      "Calling methods from different threads in a sequence.",
      "A design technique where methods return the object itself (or `this`), allowing multiple method calls to be chained together. Often embodies the Builder pattern.",
      "Overriding a method in a subclass."
    ]
  },
  {
    "questionText": "When would you prefer a `TreeMap` over a `HashMap`?",
    "correctAnswer": "When you need keys to be stored in a sorted order (natural or custom) and require efficient range-based queries.",
    "explanation": "`TreeMap` implements the `SortedMap` interface and stores its entries in a sorted order based on keys (either natural ordering or a custom `Comparator`). It provides efficient retrieval of elements within a range.",
    "options": [
      "When you need faster access time (O(1) on average).",
      "When thread-safety is a primary concern.",
      "When you need keys to be stored in a sorted order (natural or custom) and require efficient range-based queries.",
      "When you frequently iterate over the map's elements in insertion order."
    ]
  },
  {
    "questionText": "What is the primary role of the **`ServiceLoader`** API (Java SE)?",
    "correctAnswer": "To discover and load implementations of a service interface at runtime, often used for extensible applications.",
    "explanation": "`ServiceLoader` provides a simple but powerful mechanism for dynamic extensibility. It allows an application or library to discover concrete implementations of an abstract service (defined by an interface or abstract class) that are available on the classpath or module path.",
    "options": [
      "To load Java classes from a network URL.",
      "To manage and monitor the health of multiple microservices.",
      "To discover and load implementations of a service interface at runtime, often used for extensible applications.",
      "To optimize the loading time of large applications."
    ]
  },
  {
    "questionText": "Explain **Direct vs. Indirect Buffers** in Java NIO, and their performance implications.",
    "correctAnswer": "Direct buffers are allocated outside the JVM heap for direct access by native I/O operations, avoiding data copying and improving performance, while indirect buffers are on the JVM heap.",
    "explanation": "Direct buffers (created via `ByteBuffer.allocateDirect()`) bypass the JVM heap, allowing the OS to perform I/O directly on them without intermediate copying between the JVM heap and native buffers, which significantly speeds up large I/O operations. Indirect buffers (`ByteBuffer.allocate()`) are on the JVM heap and require data copying.",
    "options": [
      "Direct buffers are faster due to smaller size; indirect buffers are larger.",
      "Direct buffers are used for network I/O; indirect for file I/O.",
      "Direct buffers are allocated outside the JVM heap for direct access by native I/O operations, avoiding data copying and improving performance, while indirect buffers are on the JVM heap.",
      "Indirect buffers are thread-safe, direct buffers are not."
    ]
  },
  {
    "questionText": "What is the distinction between `yield()` and `sleep()` in terms of thread scheduling?",
    "correctAnswer": "`sleep()` puts the thread into a timed waiting state; `yield()` suggests the scheduler allows other threads to run but keeps the thread runnable.",
    "explanation": "`sleep()` causes the current thread to temporarily cease execution for a specified duration, moving it to a timed waiting state. `yield()` is a hint to the scheduler that the current thread is willing to yield its current use of a processor, allowing other threads of the same or higher priority to run, but the thread remains in a runnable state and may be scheduled again immediately.",
    "options": [
      "`yield()` releases the lock; `sleep()` does not.",
      "`sleep()` consumes CPU cycles; `yield()` does not.",
      "`sleep()` puts the thread into a timed waiting state; `yield()` suggests the scheduler allows other threads to run but keeps the thread runnable.",
      "`yield()` is guaranteed to switch threads; `sleep()` is not."
    ]
  },
  {
    "questionText": "In Java Generics, what is the meaning of a **`wildcard capture`** error, and how is it typically resolved?",
    "correctAnswer": "It occurs when a wildcard type is used in a context where a precise type is required for assignment or method invocation, typically resolved by introducing a type parameter.",
    "explanation": "Wildcard capture occurs because a wildcard (`?`) represents an unknown type, and the compiler cannot guarantee type safety for assignments or method calls that modify the list. It's often resolved by introducing a helper method with a type parameter or using bounded wildcards appropriately.",
    "options": [
      "It means a generic type parameter cannot be inferred by the compiler.",
      "It's a runtime error indicating a type mismatch in a generic collection.",
      "It occurs when a wildcard type is used in a context where a precise type is required for assignment or method invocation, typically resolved by introducing a type parameter.",
      "It's a warning that generic code might not be backward compatible."
    ]
  },
  {
    "questionText": "What is the difference between `CompletableFuture.supplyAsync()` and `CompletableFuture.runAsync()`?",
    "correctAnswer": "`supplyAsync()` runs a `Supplier` and returns a result, while `runAsync()` runs a `Runnable` and does not return a result.",
    "explanation": "`supplyAsync()` takes a `Supplier<T>` and produces a `CompletableFuture<T>`. `runAsync()` takes a `Runnable` and produces a `CompletableFuture<Void>`, indicating no return value.",
    "options": [
      "`supplyAsync()` is synchronous, `runAsync()` is asynchronous.",
      "`runAsync()` can throw exceptions, `supplyAsync()` cannot.",
      "`supplyAsync()` runs a `Supplier` and returns a result, while `runAsync()` runs a `Runnable` and does not return a result.",
      "There is no functional difference; they are aliases."
    ]
  },
  {
    "questionText": "What is the primary motivation for using the **Module System (JPMS)** in Java 9 and later?",
    "correctAnswer": "To improve application encapsulation, reliability, and performance by explicitly defining module dependencies and exports.",
    "explanation": "JPMS introduces a module layer that explicitly defines what packages are exposed (`exports`) and what other modules are required (`requires`), leading to better encapsulation (stronger than just packages), more reliable configurations, and potentially smaller runtime images.",
    "options": [
      "To replace traditional JAR files with a new archive format.",
      "To enable multiple inheritance in Java.",
      "To improve application encapsulation, reliability, and performance by explicitly defining module dependencies and exports.",
      "To provide a new way to write multi-threaded applications."
    ]
  },
  {
    "questionText": "Explain the concept of **`PermGen` vs. `Metaspace`** in JVM memory management.",
    "correctAnswer": "`PermGen` (pre-Java 8) stored class metadata and string pool, often leading to `OutOfMemoryError`; `Metaspace` (Java 8+) stores class metadata natively and expands dynamically, reducing OOM issues.",
    "explanation": "Before Java 8, `PermGen` was a fixed-size region of the heap. In Java 8+, `PermGen` was replaced by `Metaspace`, which resides in native memory (not heap) and can grow dynamically, reducing the likelihood of `OutOfMemoryError: PermGen space`.",
    "options": [
      "`PermGen` is for objects, `Metaspace` is for primitive types.",
      "`Metaspace` is always garbage collected, `PermGen` was not.",
      "`PermGen` (pre-Java 8) stored class metadata and string pool, often leading to `OutOfMemoryError`; `Metaspace` (Java 8+) stores class metadata natively and expands dynamically, reducing OOM issues.",
      "There is no functional difference; only the name changed."
    ]
  },
  {
    "questionText": "What is the primary challenge when attempting to serialize a `HashMap` that contains non-`Serializable` custom objects as keys or values?",
    "correctAnswer": "A `NotSerializableException` will be thrown at runtime when attempting to serialize the map.",
    "explanation": "If a `HashMap` or any `Serializable` object contains references to objects that are not `Serializable`, the serialization process will fail with a `NotSerializableException` unless those fields are marked `transient`.",
    "options": [
      "The `HashMap` will only serialize the serializable elements, silently dropping the rest.",
      "A `ClassCastException` will be thrown during deserialization.",
      "A `NotSerializableException` will be thrown at runtime when attempting to serialize the map.",
      "The non-serializable objects will be deep-cloned during serialization."
    ]
  },
  {
    "questionText": "When might you use `synchronized (this)` vs. `synchronized (MyClass.class)`?",
    "correctAnswer": "`synchronized (this)` locks the object instance, preventing other threads from entering synchronized instance methods/blocks of the same object. `synchronized (MyClass.class)` locks the class, preventing other threads from entering any synchronized static methods/blocks of that class.",
    "explanation": "Object-level locks (`synchronized (this)`) provide mutual exclusion for a specific object instance. Class-level locks (`synchronized (MyClass.class)`) provide mutual exclusion across all instances of a class and its static members.",
    "options": [
      "`synchronized (this)` is for static methods, `synchronized (MyClass.class)` for instance methods.",
      "`synchronized (this)` offers better performance in multi-threaded scenarios.",
      "`synchronized (this)` locks the object instance, preventing other threads from entering synchronized instance methods/blocks of the same object. `synchronized (MyClass.class)` locks the class, preventing other threads from entering any synchronized static methods/blocks of that class.",
      "They are functionally identical in most cases."
    ]
  },
  {
    "questionText": "What is **`BiFunction`** in Java 8's functional interfaces?",
    "correctAnswer": "An interface that represents a function that accepts two arguments and produces one result.",
    "explanation": "`BiFunction<T, U, R>` takes two input arguments of types `T` and `U` and returns a result of type `R`. It's part of `java.util.function` package.",
    "options": [
      "An interface that accepts one argument and returns two results.",
      "An interface that accepts two arguments and produces one result.",
      "An interface for binary operations on streams.",
      "An interface for comparing two objects."
    ]
  },
  {
    "questionText": "What is the consequence of not marking a `transient` field in a `Serializable` class that is required after deserialization?",
    "correctAnswer": "The field will be initialized to its default value (0, false, null) upon deserialization.",
    "explanation": "If a `transient` field needs a specific value after deserialization, it must be explicitly handled (e.g., in a `readObject()` method) because the default serialization mechanism will assign its default value.",
    "options": [
      "A `NotSerializableException` will be thrown.",
      "The field will retain its value from before serialization.",
      "The field will be initialized to its default value (0, false, null) upon deserialization.",
      "The deserialization process will skip this field entirely."
    ]
  },
  {
    "questionText": "What is the purpose of the **`sun.misc.Unsafe`** class, and why is its use generally discouraged?",
    "correctAnswer": "It provides low-level, direct memory access operations, but its use is dangerous, platform-dependent, and can lead to JVM crashes if misused.",
    "explanation": "`Unsafe` allows direct memory manipulation, bypassing Java's safety mechanisms. While it offers powerful capabilities (used by internal JVM classes and some high-performance libraries), it's highly dangerous, can lead to memory corruption, and is not portable, making it unsuitable for general application development.",
    "options": [
      "It's a performance monitoring tool for JVM.",
      "It provides high-level APIs for safe concurrent programming.",
      "It provides low-level, direct memory access operations, but its use is dangerous, platform-dependent, and can lead to JVM crashes if misused.",
      "It is used for secure encryption and decryption."
    ]
  },
  {
    "questionText": "Explain the concept of `Bounded Wildcards` in Java Generics (e.g., `<? extends T>`, `<? super T>`).",
    "correctAnswer": "`<? extends T>` (upper bound) allows reading from the collection (producer); `<? super T>` (lower bound) allows writing to the collection (consumer).",
    "explanation": "PECS (Producer-`extends`, Consumer-`super`) is the mnemonic. `? extends T` signifies a collection of `T` or any subtype of `T` (you can read `T`s out). `? super T` signifies a collection of `T` or any supertype of `T` (you can put `T`s into it).",
    "options": [
      "They allow a generic type to be assigned multiple specific types.",
      "They restrict a generic type to be either a class or an interface.",
      "`<? extends T>` (upper bound) allows reading from the collection (producer); `<? super T>` (lower bound) allows writing to the collection (consumer).",
      "They are used for defining type parameters in method signatures only."
    ]
  },
  {
    "questionText": "What is `Varargs` and what is one common pitfall when using it with generics?",
    "correctAnswer": "Varargs allows a method to accept a variable number of arguments. A common pitfall is heap pollution when combining varargs with non-reifiable generic types.",
    "explanation": "Varargs creates an array internally. When combined with generics (e.g., `List<String>... lists`), type erasure means the compiler can't verify the array elements' types at runtime, leading to `heap pollution` warnings and potential `ClassCastException`s.",
    "options": [
      "Varargs allows a method to accept arguments of different types.",
      "Varargs provides type safety for primitive arrays.",
      "Varargs allows a method to accept a variable number of arguments. A common pitfall is heap pollution when combining varargs with non-reifiable generic types.",
      "Varargs methods are always faster than methods with explicit array arguments."
    ]
  },
  {
    "questionText": "What is the `serialVersionUID` in `Serializable` classes, and why is it important?",
    "correctAnswer": "A unique identifier for a `Serializable` class that helps ensure compatibility during deserialization, preventing `InvalidClassException` for mismatched class versions.",
    "explanation": "The `serialVersionUID` is used to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization. If they mismatch, `InvalidClassException` is thrown.",
    "options": [
      "It specifies the maximum number of objects that can be serialized.",
      "It is a version number for the JVM's serialization mechanism.",
      "A unique identifier for a `Serializable` class that helps ensure compatibility during deserialization, preventing `InvalidClassException` for mismatched class versions.",
      "It prevents a class from being deserialized more than once."
    ]
  },
  {
    "questionText": "How does `ExecutorService.shutdown()` differ from `ExecutorService.shutdownNow()`?",
    "correctAnswer": "`shutdown()` gracefully shuts down, allowing submitted tasks to complete but accepting no new tasks. `shutdownNow()` attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution.",
    "explanation": "`shutdown()` initiates an orderly shutdown. `shutdownNow()` is more aggressive, attempting to interrupt running tasks and discarding pending ones.",
    "options": [
      "`shutdown()` immediately stops all tasks; `shutdownNow()` waits for them to complete.",
      "`shutdownNow()` returns `true` on success; `shutdown()` returns `void`.",
      "`shutdown()` gracefully shuts down, allowing submitted tasks to complete but accepting no new tasks. `shutdownNow()` attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution.",
      "There is no practical difference between them."
    ]
  },
  {
    "questionText": "What is a **`Memory Leak`** in Java, and how can it occur despite garbage collection?",
    "correctAnswer": "When objects are no longer needed but are still referenced, preventing the garbage collector from reclaiming their memory, leading to eventual `OutOfMemoryError`.",
    "explanation": "Even with automatic garbage collection, memory leaks can happen if reachable objects are no longer functionally used by the application but still hold strong references. Common causes include unclosed resources (streams, connections), static collections holding references to objects, or inner classes retaining references to outer classes when not intended.",
    "options": [
      "When the JVM fails to start due to insufficient RAM.",
      "When primitive data types consume too much memory.",
      "When objects are no longer needed but are still referenced, preventing the garbage collector from reclaiming their memory, leading to eventual `OutOfMemoryError`.",
      "When a program runs out of disk space."
    ]
  },
  {
    "questionText": "In Java NIO, what is a **`Selector`**, and why is it crucial for building highly scalable servers?",
    "correctAnswer": "A mechanism for multiplexing a single thread to monitor and manage multiple `Channel`s for I/O readiness events (e.g., read, write), avoiding the need for one thread per connection.",
    "explanation": "Selectors allow a single thread to handle multiple I/O operations simultaneously (non-blocking I/O). Instead of having one thread block per connection, the Selector can register multiple channels and notify the thread when one or more channels are ready for an I/O operation, making it ideal for high-concurrency network applications.",
    "options": [
      "A tool for selecting optimal network paths.",
      "A class for encrypting network communication.",
      "A mechanism for multiplexing a single thread to monitor and manage multiple `Channel`s for I/O readiness events (e.g., read, write), avoiding the need for one thread per connection.",
      "A way to distribute computation across multiple servers."
    ]
  },
  {
    "questionText": "What is the purpose of a **`try-catch-resources`** statement, and what kind of exceptions can it handle effectively?",
    "correctAnswer": "It ensures that resources implementing `AutoCloseable` are automatically closed. It can handle both checked and unchecked exceptions thrown within the `try` block, and correctly manages suppressed exceptions from `close()` methods.",
    "explanation": "Introduced in Java 7, it's designed to simplify resource management by guaranteeing that resources are closed. It's robust in handling exceptions: if an exception occurs in the `try` block and another in the `close()` method, the `close()` exception is suppressed but can be retrieved.",
    "options": [
      "It is only for handling `IOException`.",
      "It prevents any exceptions from being thrown within the `try` block.",
      "It ensures that resources implementing `AutoCloseable` are automatically closed. It can handle both checked and unchecked exceptions thrown within the `try` block, and correctly manages suppressed exceptions from `close()` methods.",
      "It allows resources to remain open indefinitely."
    ]
  },
  {
    "questionText": "What is the fundamental principle behind **`volatile`** keyword's memory visibility guarantees?",
    "correctAnswer": "It establishes a `happens-before` relationship: a write to a volatile variable `happens-before` any subsequent read of the same volatile variable by any thread.",
    "explanation": "`volatile` ensures that changes made by one thread to a volatile variable are immediately visible to other threads. This is achieved by ensuring that writes go directly to main memory and reads always come from main memory, bypassing CPU caches and compiler optimizations that could reorder instructions.",
    "options": [
      "It implicitly locks the variable, preventing concurrent access.",
      "It prevents compiler optimizations that would reorder instructions for thread safety.",
      "It establishes a `happens-before` relationship: a write to a volatile variable `happens-before` any subsequent read of the same volatile variable by any thread.",
      "It makes the variable immutable."
    ]
  },
  {
    "questionText": "Describe the **`Bridge Design Pattern`** and provide a scenario where it's beneficial.",
    "correctAnswer": "It decouples an abstraction from its implementation so that the two can vary independently. Beneficial for separating platform-independent APIs from platform-dependent implementations (e.g., drawing shapes on different graphics libraries).",
    "explanation": "The Bridge pattern allows the abstraction and implementation to be developed independently, e.g., a `Shape` abstraction with concrete `Circle`, `Square` types, and a `DrawingAPI` implementation with concrete `SwingAPI`, `AWTAPI` types. This avoids a proliferation of classes for each combination.",
    "options": [
      "It combines multiple methods into a single interface.",
      "It provides a way to create families of related objects without specifying their concrete classes.",
      "It decouples an abstraction from its implementation so that the two can vary independently. Beneficial for separating platform-independent APIs from platform-dependent implementations (e.g., drawing shapes on different graphics libraries).",
      "It converts an object into a form that can be reused later."
    ]
  },
  {
    "questionText": "What is **`Method Handles` vs. Reflection** regarding performance and compile-time checks?",
    "correctAnswer": "`MethodHandles` offer better performance due to less overhead and closer integration with the JVM's bytecode, and they provide stronger type checking at creation time than reflection's runtime checks.",
    "explanation": "Reflection uses `Method` objects, which have performance overhead because every invocation is a runtime check. `MethodHandles` generate bytecode snippets that are more optimized, similar to direct method calls, and perform more type checking at the time the `MethodHandle` is created, leading to better performance and earlier error detection.",
    "options": [
      "Reflection is always faster for method invocation.",
      "`MethodHandles` have no compile-time checks.",
      "`MethodHandles` offer better performance due to less overhead and closer integration with the JVM's bytecode, and they provide stronger type checking at creation time than reflection's runtime checks.",
      "Reflection supports calling private methods, `MethodHandles` do not."
    ]
  },
  {
    "questionText": "What is a **`Weak Reference`** in Java, and when is it most useful?",
    "correctAnswer": "A reference that does not prevent an object from being garbage collected. Useful for caching where objects can be removed if memory is needed.",
    "explanation": "A `WeakReference` points to an object, but if that object is only reachable via weak references, the garbage collector can reclaim it. This is useful for implementing caches where you want to store objects as long as they are strongly referenced elsewhere, but allow them to be collected if memory pressure arises.",
    "options": [
      "A reference that guarantees an object will never be garbage collected.",
      "A reference that forces garbage collection immediately.",
      "A reference that does not prevent an object from being garbage collected. Useful for caching where objects can be removed if memory is needed.",
      "A reference that creates a deep copy of an object."
    ]
  },
  {
    "questionText": "Explain **`heap pollution`** in Java Generics and provide a scenario where it can occur.",
    "correctAnswer": "Occurs when a variable of a parameterized type refers to an object that is not of that parameterized type, typically due to raw types or `varargs` with non-reifiable types.",
    "explanation": "Heap pollution means that the compile-time type-safety guarantees are violated. A common scenario is when a method with a `varargs` of a generic type (`List<String>... lists`) is invoked, and `List<Integer>` is passed. Due to type erasure, the array created internally is `List[]`, allowing this unsafe assignment.",
    "options": [
      "When the garbage collector runs too frequently.",
      "When too many objects are created on the heap, leading to `OutOfMemoryError`.",
      "Occurs when a variable of a parameterized type refers to an object that is not of that parameterized type, typically due to raw types or `varargs` with non-reifiable types.",
      "When a method returns a null value instead of an empty collection."
    ]
  },
  {
    "questionText": "What is the purpose of the `Future` interface in Java concurrency?",
    "correctAnswer": "To represent the result of an asynchronous computation, allowing you to check if the computation is complete, wait for its completion, and retrieve the result.",
    "explanation": "`Future` is a handle to the result of an asynchronous operation. You can use its methods like `isDone()`, `get()` (which blocks until completion), and `cancel()`.",
    "options": [
      "To define a task that can be executed repeatedly.",
      "To provide a callback mechanism for asynchronous events.",
      "To represent the result of an asynchronous computation, allowing you to check if the computation is complete, wait for its completion, and retrieve the result.",
      "To schedule tasks to run at a specific time."
    ]
  },
  {
    "questionText": "What is the **`Diamond Problem`** in the context of Java's default methods in interfaces, and how is it resolved?",
    "correctAnswer": "When a class inherits the same default method from multiple interfaces, causing ambiguity. Java resolves it by requiring the implementing class to explicitly override the method or call one of the super interface's default methods.",
    "explanation": "Java 8's default methods can lead to situations where a class inherits identical default methods from two different interfaces. The compiler reports an error, forcing the implementing class to explicitly provide its own implementation or specify which inherited default method to use using `Interface.super.method()`. This prevents the ambiguity present in multiple inheritance of implementation.",
    "options": [
      "It's a problem when a class implements too many interfaces.",
      "It refers to the issue of circular dependencies between classes.",
      "When a class inherits the same default method from multiple interfaces, causing ambiguity. Java resolves it by requiring the implementing class to explicitly override the method or call one of the super interface's default methods.",
      "It occurs when a class has too many constructors."
    ]
  },
  {
    "questionText": "Explain the role of `java.lang.instrument` package.",
    "correctAnswer": "It provides services that allow Java programming language agents to instrument programs running on the JVM, enabling modification of bytecode for profiling, monitoring, or transformation.",
    "explanation": "The `java.lang.instrument` package is typically used by profilers, debuggers, and code coverage tools. It allows agents to transform class files at load time or even modify already loaded classes, providing powerful hooks for bytecode manipulation and runtime analysis without modifying the source code.",
    "options": [
      "It allows dynamic loading of classes from a network.",
      "It provides tools for code generation at compile time.",
      "It provides services that allow Java programming language agents to instrument programs running on the JVM, enabling modification of bytecode for profiling, monitoring, or transformation.",
      "It is used for secure communication between JVMs."
    ]
  },
  {
    "questionText": "What is **`Bi-directional Relationship`** in JPA/Hibernate, and what is the common pitfall with it?",
    "correctAnswer": "When two entities reference each other, establishing a link in both directions. The common pitfall is managing both sides of the relationship consistently to avoid infinite loops or synchronization issues.",
    "explanation": "For example, a `User` has `List<Address>` and `Address` has a `User`. The pitfall lies in ensuring that when you add an address to a user, you also set the user on the address and vice-versa, especially during persistence to avoid orphaned records or unintended behavior like infinite loops in `toString()` or `equals()/hashCode()`.",
    "options": [
      "When an entity can be accessed from two different tables.",
      "When a single entity class has two primary keys.",
      "When two entities reference each other, establishing a link in both directions. The common pitfall is managing both sides of the relationship consistently to avoid infinite loops or synchronization issues.",
      "When an entity can be saved to two different databases."
    ]
  },
  {
    "questionText": "What is the difference between `Stream.parallel()` and using `CompletableFuture` for parallel processing?",
    "correctAnswer": "`Stream.parallel()` uses the ForkJoinPool for parallel processing of collection operations, while `CompletableFuture` provides explicit control over asynchronous tasks and their composition, often using a custom `ExecutorService`.",
    "explanation": "`Stream.parallel()` is a declarative approach for data parallelism on collections, leveraging the shared common `ForkJoinPool`. `CompletableFuture` is an imperative approach for task parallelism, giving more control over threads, error handling, and chaining independent asynchronous computations.",
    "options": [
      "`Stream.parallel()` is always faster than `CompletableFuture`.",
      "`CompletableFuture` is only for blocking I/O operations.",
      "`Stream.parallel()` uses the ForkJoinPool for parallel processing of collection operations, while `CompletableFuture` provides explicit control over asynchronous tasks and their composition, often using a custom `ExecutorService`.",
      "They are interchangeable for any parallel processing need."
    ]
  },
  {
    "questionText": "Explain `Read-Write Lock` (`ReentrantReadWriteLock`) and its benefits.",
    "correctAnswer": "It allows multiple readers to access a resource concurrently but requires exclusive access for a writer, improving concurrency in read-heavy scenarios.",
    "explanation": "A `ReadWriteLock` maintains a pair of associated locks, one for read-only operations and one for writing. The read lock can be held by multiple reader threads simultaneously as long as no writer holds the write lock. The write lock is exclusive.",
    "options": [
      "It allows only one reader or one writer to access a resource at a time.",
      "It prioritizes writers over readers, leading to writer starvation.",
      "It allows multiple readers to access a resource concurrently but requires exclusive access for a writer, improving concurrency in read-heavy scenarios.",
      "It only works with primitive data types."
    ]
  },
  {
    "questionText": "What is `Thread.interrupt()` and how should a thread typically respond to it?",
    "correctAnswer": "`Thread.interrupt()` sets a thread's interrupted status flag. A thread should regularly check this flag (e.g., `Thread.interrupted()`, `isInterrupted()`) and respond by gracefully stopping its current activity and possibly exiting.",
    "explanation": "It's a cooperative mechanism. `interrupt()` doesn't forcibly stop a thread; it just sets a flag. If a thread is blocked in certain interruptible operations (like `sleep()`, `wait()`, `join()`), it will throw an `InterruptedException`. Otherwise, the thread must explicitly check its interrupted status and decide how to respond.",
    "options": [
      "It forcibly stops a thread immediately.",
      "It pauses a thread indefinitely until `resume()` is called.",
      "`Thread.interrupt()` sets a thread's interrupted status flag. A thread should regularly check this flag (e.g., `Thread.interrupted()`, `isInterrupted()`) and respond by gracefully stopping its current activity and possibly exiting.",
      "It is used to change a thread's priority."
    ]
  },
  {
    "questionText": "What is the concept of `Immutable Collections` (e.g., `List.of()`, `Set.of()` from Java 9)?",
    "correctAnswer": "Collections whose content cannot be modified after creation, offering thread safety, predictability, and suitability for caching.",
    "explanation": "Immutable collections are fixed in size and content once created. Any attempt to modify them (add, remove, clear) will result in an `UnsupportedOperationException`. They are inherently thread-safe and can simplify reasoning about data flow.",
    "options": [
      "Collections that automatically grow and shrink as needed.",
      "Collections that are always sorted.",
      "Collections whose content cannot be modified after creation, offering thread safety, predictability, and suitability for caching.",
      "Collections that allow duplicate elements."
    ]
  },
  {
    "questionText": "What is **`Class.forName()`** and when might it throw a `ClassNotFoundException`?",
    "correctAnswer": "It dynamically loads a class into the JVM. It throws `ClassNotFoundException` if the class cannot be found on the classpath.",
    "explanation": "`Class.forName()` loads the class into memory and initializes it (executes static blocks). It's commonly used by JDBC drivers, reflection, and dynamic class loading scenarios. The exception indicates the class file is missing or not reachable.",
    "options": [
      "It creates a new instance of a class.",
      "It retrieves an existing class from memory.",
      "It dynamically loads a class into the JVM. It throws `ClassNotFoundException` if the class cannot be found on the classpath.",
      "It converts a class name into a package name."
    ]
  },
  {
    "questionText": "What is the difference between `Collection.removeIf()` and `Iterator.remove()`?",
    "correctAnswer": "`Collection.removeIf()` removes all elements satisfying a given predicate using an `Iterator` internally and is generally safer for concurrent modifications. `Iterator.remove()` removes the last element returned by `next()` and must be called after `next()` for safety.",
    "explanation": "`removeIf()` (Java 8+) provides a convenient, safe, and often optimized way to remove elements based on a condition from a collection. `Iterator.remove()` is the safe way to remove elements during manual iteration, but it specifically removes the *last* element retrieved by `next()`. Attempting to modify the collection outside of `Iterator.remove()` during iteration results in `ConcurrentModificationException`.",
    "options": [
      "`Collection.removeIf()` is for `Set`s only; `Iterator.remove()` for `List`s.",
      "`Iterator.remove()` is faster for large collections.",
      "`Collection.removeIf()` removes all elements satisfying a given predicate using an `Iterator` internally and is generally safer for concurrent modifications. `Iterator.remove()` removes the last element returned by `next()` and must be called after `next()` for safety.",
      "`Collection.removeIf()` modifies the original collection; `Iterator.remove()` creates a new one."
    ]
  },
  {
    "questionText": "What is the primary motivation for using **`CompletableFuture`** in modern Java asynchronous programming?",
    "correctAnswer": "To enable asynchronous, non-blocking computations with easy chaining and composition of dependent tasks, improving responsiveness and resource utilization.",
    "explanation": "`CompletableFuture` allows you to write non-blocking code, making your application more responsive. It provides a rich set of methods for combining, transforming, and handling exceptions of asynchronous computations, avoiding the complexities of callback hell.",
    "options": [
      "To provide a synchronized wrapper for any object.",
      "To perform complex mathematical calculations in parallel.",
      "To enable asynchronous, non-blocking computations with easy chaining and composition of dependent tasks, improving responsiveness and resource utilization.",
      "To replace the traditional `Thread` class."
    ]
  },
  {
    "questionText": "Explain the concept of `Internal Iteration` vs. `External Iteration` in the context of Java Streams.",
    "correctAnswer": "Internal iteration (Streams) means the library controls the iteration, optimizing it for parallelism. External iteration (loops with `Iterator`/`for-each`) means the programmer controls the iteration explicitly.",
    "explanation": "Streams use internal iteration, where you tell the stream *what* to do, not *how* to do it. This allows the Stream API to optimize execution, including parallel processing. External iteration means you explicitly control the loop (e.g., `for (T obj : collection)` or `while (iterator.hasNext())`).",
    "options": [
      "Internal iteration is for `List`s, external for `Set`s.",
      "External iteration is always faster.",
      "Internal iteration (Streams) means the library controls the iteration, optimizing it for parallelism. External iteration (loops with `Iterator`/`for-each`) means the programmer controls the iteration explicitly.",
      "Internal iteration allows modifying the collection during iteration."
    ]
  },
  {
    "questionText": "What is a **`Soft Reference`** in Java, and how does it relate to garbage collection?",
    "correctAnswer": "A reference that allows an object to be garbage collected only if the JVM is running low on memory. Useful for implementing memory-sensitive caches.",
    "explanation": "An object referenced only by soft references is eligible for garbage collection only if the JVM determines that memory is running low. This makes soft references ideal for caches that can be cleared under memory pressure.",
    "options": [
      "A reference that keeps an object in memory indefinitely.",
      "A reference that causes an object to be finalized immediately.",
      "A reference that allows an object to be garbage collected only if the JVM is running low on memory. Useful for implementing memory-sensitive caches.",
      "A reference that is always cleared after a specific time interval."
    ]
  },
  {
    "questionText": "What is **`Type Inference`** in Java 8+ and how does it relate to Lambda Expressions and `var` (Java 10+)?",
    "correctAnswer": "The compiler's ability to deduce generic type parameters or local variable types from context, simplifying code. Lambda expressions rely on it, and `var` leverages it for local variable declarations.",
    "explanation": "Type inference allows you to omit explicit type arguments in many situations, reducing boilerplate code. Lambda expressions (e.g., `(arg) -> { ... }`) often rely on the compiler inferring the types of arguments and the functional interface. `var` for local variable type inference (Java 10+) further extends this by allowing the compiler to deduce the concrete type of a local variable.",
    "options": [
      "It's a process of explicitly casting types at runtime.",
      "It's a feature that prevents any type errors at compile time.",
      "The compiler's ability to deduce generic type parameters or local variable types from context, simplifying code. Lambda expressions rely on it, and `var` leverages it for local variable declarations.",
      "It enables dynamic type changes during program execution."
    ]
  },
  {
    "questionText": "What is the meaning of the `transient` keyword in the context of Java Serialization?",
    "correctAnswer": "It marks a field such that it will not be serialized when an object is written to a persistent storage or transmitted over a network.",
    "explanation": "When an object implementing `Serializable` is written to an `ObjectOutputStream`, the values of `transient` fields are ignored. Upon deserialization, these fields will be initialized to their default values (e.g., `0` for `int`, `null` for objects).",
    "options": [
      "It makes a field volatile for thread safety.",
      "It makes a field immutable after initialization.",
      "It marks a field such that it will not be serialized when an object is written to a persistent storage or transmitted over a network.",
      "It indicates that a field can only be accessed by static methods."
    ]
  },
  {
    "questionText": "What is **`ConcurrentModificationException`** and when does it typically occur?",
    "correctAnswer": "A runtime exception thrown when a collection is structurally modified (added/removed elements) while an iteration (e.g., `Iterator`, `for-each` loop) over it is in progress.",
    "explanation": "This exception is a 'fail-fast' mechanism. It does not guarantee that concurrent modification will always throw an exception, but it is typically thrown to alert the programmer to a potential bug where the behavior of iteration is undefined under concurrent modification.",
    "options": [
      "When two threads try to access the same method at the same time.",
      "When a collection element is modified during iteration without using the iterator's `set()` method.",
      "A runtime exception thrown when a collection is structurally modified (added/removed elements) while an iteration (e.g., `Iterator`, `for-each` loop) over it is in progress.",
      "When a static method attempts to modify an instance variable."
    ]
  },
  {
    "questionText": "What is a **`Proxy`** object in Java, and when is it useful?",
    "correctAnswer": "A class that provides a surrogate or placeholder for another object to control access to it. Useful for implementing lazy initialization, logging, security, or remote object access.",
    "explanation": "The Proxy pattern allows you to control access to an object. In Java, `java.lang.reflect.Proxy` can dynamically create proxy classes that implement specified interfaces, forwarding method calls to an `InvocationHandler`. This is common in AOP, ORM frameworks, and RMI.",
    "options": [
      "A class that simulates a database connection.",
      "A lightweight alternative to `Thread` for simple tasks.",
      "A class that provides a surrogate or placeholder for another object to control access to it. Useful for implementing lazy initialization, logging, security, or remote object access.",
      "A mechanism for creating immutable objects."
    ]
  },
  {
    "questionText": "What is the difference between `System.exit(0)` and `return` in the `main` method?",
    "correctAnswer": "`System.exit(0)` terminates the entire JVM regardless of other running threads, while `return` simply exits the `main` method, and the JVM continues as long as non-daemon threads are active.",
    "explanation": "`System.exit()` causes immediate termination of the Java Virtual Machine. `return` only exits the current method. If other non-daemon threads are running, the JVM will continue to execute after the `main` method returns.",
    "options": [
      "`System.exit(0)` signals an error, `return` signals success.",
      "There is no functional difference in the `main` method.",
      "`System.exit(0)` terminates the entire JVM regardless of other running threads, while `return` simply exits the `main` method, and the JVM continues as long as non-daemon threads are active.",
      "`return` is only for methods that return a value."
    ]
  },
  {
    "questionText": "Explain **`IdentityHashMap`** vs. `HashMap`.",
    "correctAnswer": "`IdentityHashMap` compares keys using reference equality (`==`), while `HashMap` compares keys using `equals()` and `hashCode()`.",
    "explanation": "`IdentityHashMap` is useful when you need to distinguish between two objects that are `equals()` but are distinct object instances. It directly compares memory addresses for keys, rather than their logical equality.",
    "options": [
      "`IdentityHashMap` is thread-safe; `HashMap` is not.",
      "`HashMap` is faster for primitive keys.",
      "`IdentityHashMap` compares keys using reference equality (`==`), while `HashMap` compares keys using `equals()` and `hashCode()`.",
      "`IdentityHashMap` allows `null` keys, `HashMap` does not."
    ]
  },
  {
    "questionText": "What is the concept of **`Guava Cache`** (`LoadingCache`) and its advantages over `ConcurrentHashMap` for caching?",
    "correctAnswer": "Guava Cache provides an in-memory caching solution with features like automatic loading, eviction policies (LRU, time-based), and statistics, which `ConcurrentHashMap` doesn't offer out-of-the-box.",
    "explanation": "While `ConcurrentHashMap` is excellent for concurrent, thread-safe access to a map, it doesn't provide caching features like automatic loading of values when missing, or policies for evicting entries based on size, time, or reference type. Guava Cache builds upon `ConcurrentHashMap` to add these sophisticated caching capabilities.",
    "options": [
      "Guava Cache is a persistent database cache, `ConcurrentHashMap` is in-memory.",
      "Guava Cache only supports `String` keys.",
      "Guava Cache provides an in-memory caching solution with features like automatic loading, eviction policies (LRU, time-based), and statistics, which `ConcurrentHashMap` doesn't offer out-of-the-box.",
      "`ConcurrentHashMap` is for single-threaded use only."
    ]
  },
  {
    "questionText": "What is the **`try-catch-finally`** block structure's behavior when an exception is thrown in the `try` block, and another is thrown in the `finally` block?",
    "correctAnswer": "The exception from the `finally` block will be propagated, and the original exception from the `try` block will be suppressed.",
    "explanation": "If an exception occurs in the `finally` block, it takes precedence and is thrown. The original exception from the `try` block (if any) is then added as a 'suppressed' exception to the exception thrown by the `finally` block.",
    "options": [
      "The exception from the `try` block is always propagated.",
      "The program will terminate immediately without any exception being thrown.",
      "Both exceptions are wrapped into a new `RuntimeException`.",
      "The exception from the `finally` block will be propagated, and the original exception from the `try` block will be suppressed."
    ]
  },
  {
    "questionText": "What is **`Method References`** (Java 8) and its relationship to `Lambda Expressions`?",
    "correctAnswer": "`Method References` are a concise way to refer to methods or constructors by their names. They are syntactic sugar for specific lambda expressions where the lambda simply calls an existing method.",
    "explanation": "A method reference is a shorthand for a lambda expression that does nothing but call an existing method. For example, `System.out::println` is a method reference equivalent to the lambda `s -> System.out.println(s)`.",
    "options": [
      "`Method References` are a replacement for `Lambda Expressions`.",
      "`Lambda Expressions` can only refer to static methods.",
      "`Method References` are a concise way to refer to methods or constructors by their names. They are syntactic sugar for specific lambda expressions where the lambda simply calls an existing method.",
      "`Method References` allow passing arguments by reference."
    ]
  },
  {
    "questionText": "Explain the concept of **`Type Token`** in Java Generics.",
    "correctAnswer": "It's a way to capture and retain generic type information at runtime, usually by creating an anonymous inner class of a generic type, to overcome type erasure limitations.",
    "explanation": "Due to type erasure, generic type parameters are not available at runtime. A type token (e.g., `new TypeToken<List<String>>() {}`) uses an anonymous inner class whose superclass has the generic type information embedded in its declaration. This allows frameworks (like GSON, Guice) to extract the full generic type at runtime using reflection.",
    "options": [
      "A token used for type safety in multi-threaded applications.",
      "A unique identifier for a specific generic type.",
      "It's a way to capture and retain generic type information at runtime, usually by creating an anonymous inner class of a generic type, to overcome type erasure limitations.",
      "A special keyword for defining new generic types."
    ]
  },
  {
    "questionText": "What is the purpose of `WeakHashMap` and how does it affect garbage collection?",
    "correctAnswer": "Keys in a `WeakHashMap` are held using weak references. If a key object is not strongly referenced elsewhere, its entry in the map can be garbage collected, preventing memory leaks for temporary keys.",
    "explanation": "`WeakHashMap` is used when you want the map to automatically discard entries once their keys are no longer strongly referenced by other parts of the application. This helps in managing memory for caches where entries should expire if their keys are no longer in use.",
    "options": [
      "It prevents garbage collection of its keys.",
      "It provides a synchronized version of `HashMap`.",
      "Keys in a `WeakHashMap` are held using weak references. If a key object is not strongly referenced elsewhere, its entry in the map can be garbage collected, preventing memory leaks for temporary keys.",
      "Values in a `WeakHashMap` are automatically removed after a timeout."
    ]
  },
  {
    "questionText": "What is the significance of the `transient` keyword in Java serialization?",
    "correctAnswer": "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
    "explanation": "When an object implementing `Serializable` is serialized, `transient` fields are ignored. They are not stored in the serialized form and will be initialized to their default values (e.g., `null` for objects, `0` for numeric types) upon deserialization.",
    "options": [
      "It prevents a field from being modified after initialization.",
      "It makes a field visible across different threads.",
      "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
      "It creates a temporary copy of a field."
    ]
  },
  {
    "questionText": "Describe `JNI` (Java Native Interface) and its primary use case.",
    "correctAnswer": "A programming framework that enables Java code running in a JVM to call, and be called by, native applications and libraries written in other languages (like C, C++, Assembly). Used for platform-specific functionalities or performance-critical operations.",
    "explanation": "JNI provides a bridge between Java and native code. It's used when you need to interact with platform-specific hardware, existing legacy libraries written in other languages, or for highly performance-sensitive code where direct hardware access is needed.",
    "options": [
      "A tool for converting Java code to JavaScript.",
      "A framework for network communication between Java applications.",
      "A programming framework that enables Java code running in a JVM to call, and be called by, native applications and libraries written in other languages (like C, C++, Assembly). Used for platform-specific functionalities or performance-critical operations.",
      "A mechanism for securing Java applications from external attacks."
    ]
  },
  {
    "questionText": "What is the difference between `Stream.forEach()` and `Iterable.forEach()`?",
    "correctAnswer": "`Stream.forEach()` is a terminal stream operation that may execute in parallel and does not guarantee encounter order. `Iterable.forEach()` is a default method on `Iterable` that iterates sequentially and preserves encounter order.",
    "explanation": "`Stream.forEach()` is part of the `Stream` API, designed for processing data in a pipeline, and its execution order for parallel streams is not guaranteed. `Iterable.forEach()` (introduced in Java 8) is a more convenient way to iterate over collections sequentially, similar to an enhanced `for` loop.",
    "options": [
      "`Stream.forEach()` can modify the underlying collection; `Iterable.forEach()` cannot.",
      "`Iterable.forEach()` is faster for large datasets.",
      "`Stream.forEach()` is a terminal stream operation that may execute in parallel and does not guarantee encounter order. `Iterable.forEach()` is a default method on `Iterable` that iterates sequentially and preserves encounter order.",
      "There is no functional difference; they are aliases."
    ]
  },
  {
    "questionText": "What is the concept of a **`StampedLock`'s optimistic read lock**?",
    "correctAnswer": "It's a non-blocking read operation that doesn't acquire a lock. It returns a 'stamp' that must be validated later to ensure no write operation occurred during the read.",
    "explanation": "An optimistic read doesn't block writers, making it very performant for read-heavy scenarios. You get a `stamp` before reading, read the data, then `validate()` the stamp. If `validate()` returns `false`, a write occurred, and you must acquire a pessimistic read lock or retry the optimistic read.",
    "options": [
      "It's a read lock that can be acquired by only one reader at a time.",
      "It's a read lock that prioritizes writers.",
      "It's a non-blocking read operation that doesn't acquire a lock. It returns a 'stamp' that must be validated later to ensure no write operation occurred during the read.",
      "It allows both reading and writing concurrently without any locking."
    ]
  },
  {
    "questionText": "How does `WeakReference` interact with the `ReferenceQueue`?",
    "correctAnswer": "When a `WeakReference`'s referent is garbage collected, the `WeakReference` object itself is enqueued into its associated `ReferenceQueue`, allowing for post-GC cleanup actions.",
    "explanation": "A `ReferenceQueue` is used to be notified when the objects pointed to by weak (or soft, or phantom) references are about to be garbage collected. This enables cleaning up associated resources or performing other actions at that precise moment.",
    "options": [
      "It causes the garbage collector to immediately reclaim the referent.",
      "It prevents the referent from ever being garbage collected.",
      "When a `WeakReference`'s referent is garbage collected, the `WeakReference` object itself is enqueued into its associated `ReferenceQueue`, allowing for post-GC cleanup actions.",
      "It stores a strong reference to the referent until manually removed."
    ]
  },
  {
    "questionText": "What is the primary difference between `Set` and `Map` in Java Collections?",
    "correctAnswer": "`Set` stores unique elements only, while `Map` stores key-value pairs where keys are unique.",
    "explanation": "`Set` is a collection of unique elements (like mathematical sets). `Map` is a collection that maps keys to values, where each key must be unique.",
    "options": [
      "`Set` allows duplicate elements, `Map` does not.",
      "`Map` is always sorted, `Set` is not.",
      "`Set` stores unique elements only, while `Map` stores key-value pairs where keys are unique.",
      "`Set` is faster for lookups than `Map`."
    ]
  },
  {
    "questionText": "Explain the concept of **`Defensive Copying`** when creating immutable objects.",
    "correctAnswer": "When an immutable class receives mutable objects as constructor arguments or returns mutable internal state, it must create a new copy of those mutable objects to prevent external modification of its internal state.",
    "explanation": "If an immutable class's constructor or getter methods directly store/return references to mutable objects passed in or held internally, the 'immutable' object's state can still be changed indirectly. Defensive copying ensures that the immutable object always works with its own independent copies of mutable components.",
    "options": [
      "Copying objects to a safe location before serialization.",
      "Creating a backup of a class's bytecode.",
      "When an immutable class receives mutable objects as constructor arguments or returns mutable internal state, it must create a new copy of those mutable objects to prevent external modification of its internal state.",
      "Duplicating a method's implementation to handle edge cases."
    ]
  },
  {
    "questionText": "What is `Thread starvation` in Java concurrency?",
    "correctAnswer": "When a greedy thread or improperly configured scheduling constantly monopolizes the CPU, preventing other threads from getting a chance to run.",
    "explanation": "Starvation occurs when a thread is perpetually denied access to a shared resource or CPU time, not necessarily due to a deadlock, but due to other threads continuously acquiring the resource or higher-priority threads constantly running.",
    "options": [
      "When a thread runs out of memory.",
      "When a thread is waiting indefinitely for a lock that is never released.",
      "When a greedy thread or improperly configured scheduling constantly monopolizes the CPU, preventing other threads from getting a chance to run.",
      "When a thread fails to start."
    ]
  },
  {
    "questionText": "What is the primary motivation for introducing **`Optional`** in Java 8?",
    "correctAnswer": "To provide a type-safe way to represent the presence or absence of a value, thereby reducing `NullPointerException`s and improving code clarity.",
    "explanation": "`Optional` forces developers to explicitly consider the case where a value might be absent, rather than implicitly relying on `null` checks, which are prone to `NPE`s.",
    "options": [
      "To replace traditional `try-catch` blocks.",
      "To optimize memory usage for nullable values.",
      "To provide a type-safe way to represent the presence or absence of a value, thereby reducing `NullPointerException`s and improving code clarity.",
      "To enable lazy initialization of variables."
    ]
  },
  {
    "questionText": "How does `ConcurrentHashMap` achieve high concurrency compared to `Hashtable` or `Collections.synchronizedMap()`?",
    "correctAnswer": "`ConcurrentHashMap` uses a fine-grained locking mechanism (segment locking or node-level locking, depending on version) that allows multiple threads to access different parts of the map concurrently, rather than locking the entire map.",
    "explanation": "Unlike `Hashtable` or `synchronizedMap` which apply a single lock to the entire map, `ConcurrentHashMap` segments the map and locks only the relevant segment or even individual nodes (Java 8+), allowing multiple concurrent reads and writes to different parts of the map.",
    "options": [
      "It uses `volatile` keyword on all internal fields.",
      "It makes all its methods `synchronized`.",
      "`ConcurrentHashMap` uses a fine-grained locking mechanism (segment locking or node-level locking, depending on version) that allows multiple threads to access different parts of the map concurrently, rather than locking the entire map.",
      "It does not support concurrent write operations."
    ]
  },
  {
    "questionText": "What is a **`Memory Barrier`** (or `Memory Fence`) and its relation to `volatile` and `synchronized`?",
    "correctAnswer": "A hardware-level instruction that enforces a specific ordering of memory operations (reads and writes) by preventing reordering across the barrier. `volatile` and `synchronized` implicitly use memory barriers to ensure visibility and ordering.",
    "explanation": "Memory barriers are low-level CPU instructions that prevent certain types of memory reordering. Java's `volatile` and `synchronized` constructs translate into these barriers, ensuring that writes to shared variables become visible to other threads and that instructions are executed in a specific order, as per the Java Memory Model.",
    "options": [
      "A dedicated memory region for storing thread-local variables.",
      "A software mechanism for detecting memory leaks.",
      "A hardware-level instruction that enforces a specific ordering of memory operations (reads and writes) by preventing reordering across the barrier. `volatile` and `synchronized` implicitly use memory barriers to ensure visibility and ordering.",
      "A design pattern for managing concurrent memory access."
    ]
  },
  {
    "questionText": "What is `Type Erasure` in Java Generics, and how does it impact Reflection?",
    "correctAnswer": "The process where generic type information is removed during compilation. This means reflection cannot directly retrieve the actual type arguments of a generic type at runtime.",
    "explanation": "While you can get the generic type signatures from classes/methods, the actual type arguments (e.g., `String` in `List<String>`) are erased. You can't, for example, directly check if a `List` contains `String`s at runtime using `instanceof` because it only sees `List`.",
    "options": [
      "Reflection can always retrieve the exact generic type parameters at runtime.",
      "Type erasure only applies to primitive types.",
      "The process where generic type information is removed during compilation. This means reflection cannot directly retrieve the actual type arguments of a generic type at runtime.",
      "It improves runtime performance by removing unnecessary type checks."
    ]
  },
  {
    "questionText": "What is the key benefit of using `java.time` (Date and Time API, Java 8+) over `java.util.Date` and `java.util.Calendar`?",
    "correctAnswer": "It's immutable, thread-safe, provides clear separation of date/time concepts, offers better readability, and addresses many design flaws of the legacy API.",
    "explanation": "The legacy `Date` and `Calendar` classes were mutable, not thread-safe, had confusing API design (e.g., months starting from 0), and poor support for time zones. The `java.time` package (JSR-310) solves these issues with immutable objects and a fluent API.",
    "options": [
      "It automatically handles all time zone conversions without explicit configuration.",
      "It allows direct manipulation of system clock settings.",
      "It's immutable, thread-safe, provides clear separation of date/time concepts, offers better readability, and addresses many design flaws of the legacy API.",
      "It's primarily for database timestamp operations."
    ]
  },
  {
    "questionText": "What is a **`BiConsumer`** in Java 8 Streams?",
    "correctAnswer": "An interface that represents an operation that accepts two input arguments and returns no result.",
    "explanation": "A `BiConsumer<T, U>` is a functional interface that takes two arguments (of types `T` and `U`) and performs an action, without returning any value. It's often used in `forEach` or `Map.forEach` operations.",
    "options": [
      "An interface that consumes two streams and produces one.",
      "An interface that returns two results.",
      "An interface that represents an operation that accepts two input arguments and returns no result.",
      "An interface for combining two functions."
    ]
  },
  {
    "questionText": "What is the purpose of **`try-finally`** block without a `catch` block?",
    "correctAnswer": "To ensure that cleanup code in the `finally` block always executes, even if an exception is thrown in the `try` block and not caught within the method.",
    "explanation": "If no `catch` block is present, and an exception occurs in the `try` block, the `finally` block will still execute, and then the exception will be propagated up the call stack.",
    "options": [
      "It's a syntax error.",
      "It acts as a default catch-all for all exceptions.",
      "To ensure that cleanup code in the `finally` block always executes, even if an exception is thrown in the `try` block and not caught within the method.",
      "It prevents any exceptions from being thrown."
    ]
  },
  {
    "questionText": "What is the difference between `Iterable` and `Iterator` in Java?",
    "correctAnswer": "`Iterable` is an interface that allows an object to be the target of the `for-each` loop; `Iterator` is an interface that provides methods to traverse elements in a collection (`hasNext()`, `next()`, `remove()`).",
    "explanation": "A class that implements `Iterable` provides an `iterator()` method that returns an `Iterator`. The `for-each` loop works with any class that implements `Iterable`.",
    "options": [
      "There is no difference; they are synonyms.",
      "`Iterator` is for primitive types, `Iterable` for objects.",
      "`Iterable` is an interface that allows an object to be the target of the `for-each` loop; `Iterator` is an interface that provides methods to traverse elements in a collection (`hasNext()`, `next()`, `remove()`).",
      "`Iterable` supports concurrent modification, `Iterator` does not."
    ]
  },
  {
    "questionText": "Explain the concept of **`Reifiable` vs. `Non-Reifiable` Types** in Java Generics.",
    "correctAnswer": "`Reifiable` types have all their type information available at runtime (e.g., raw types, non-generic types). `Non-reifiable` types have some or all of their type information erased at runtime (e.g., `List<String>`).",
    "explanation": "Due to type erasure, generic type parameters are not present at runtime. A type is reifiable if its complete type information is available at runtime. `List<String>` is non-reifiable because at runtime it's just `List`. This is why you can't use `instanceof` with generic types (`obj instanceof List<String>` is illegal).",
    "options": [
      "`Reifiable` types can be generic, `non-reifiable` types cannot.",
      "`Non-reifiable` types are faster at runtime.",
      "`Reifiable` types have all their type information available at runtime (e.g., raw types, non-generic types). `Non-reifiable` types have some or all of their type information erased at runtime (e.g., `List<String>`).",
      "All generic types are reifiable after compilation."
    ]
  },
  {
    "questionText": "What is the problem with using `Thread.stop()` and `Thread.suspend()`?",
    "correctAnswer": "They are deprecated because they are inherently unsafe and can lead to deadlocks or corrupted shared data by releasing monitors at unpredictable times.",
    "explanation": "These methods are unsafe because they can interrupt a thread at an arbitrary point, potentially leaving shared resources in an inconsistent state or causing deadlocks. The preferred way to stop or pause threads is through cooperative mechanisms (e.g., checking an `interrupted` flag, using `wait()/notify()`).",
    "options": [
      "They cause the JVM to crash immediately.",
      "They consume excessive CPU resources.",
      "They are deprecated because they are inherently unsafe and can lead to deadlocks or corrupted shared data by releasing monitors at unpredictable times.",
      "They cannot be used with `ExecutorService`."
    ]
  },
  {
    "questionText": "What is the purpose of a **`Record`** in Java (Java 16+)?",
    "correctAnswer": "To provide a concise syntax for declaring data classes, automatically generating canonical constructor, accessor methods, `equals()`, `hashCode()`, and `toString()`. They are implicitly final.",
    "explanation": "Records are a new type of class designed to model plain data aggregates. They aim to reduce boilerplate code for classes that primarily serve as data carriers. They are implicitly `final` and `abstract` cannot be declared.",
    "options": [
      "To create immutable collections.",
      "To define a new type of `enum`.",
      "To provide a concise syntax for declaring data classes, automatically generating canonical constructor, accessor methods, `equals()`, `hashCode()`, and `toString()`. They are implicitly final.",
      "To manage database transactions."
    ]
  },
  {
    "questionText": "What is `ThreadLocalRandom` (Java 7+), and why is it preferred over `Random` in multi-threaded contexts?",
    "correctAnswer": "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
    "explanation": "Instances of `java.util.Random` are thread-safe but may suffer from contention in highly concurrent environments because multiple threads try to update the same seed. `ThreadLocalRandom` avoids this by giving each thread its own `Random` instance, eliminating contention and improving performance.",
    "options": [
      "It generates truly random numbers.",
      "It is a legacy class for backward compatibility.",
      "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
      "It uses a larger seed for more randomness."
    ]
  },
  {
    "questionText": "Explain the concept of **`Externalizable`** interface in Java Serialization.",
    "correctAnswer": "It allows a class to define its own custom serialization format, giving full control over the process, unlike `Serializable` which uses default serialization.",
    "explanation": "Implementing `Externalizable` (and its `writeExternal()` and `readExternal()` methods) gives the developer complete control over what is saved and restored, including versioning logic. This is typically used for performance optimization (saving less data) or when dealing with complex object graphs.",
    "options": [
      "It is a marker interface, similar to `Serializable`.",
      "It prevents a class from being serialized.",
      "It allows a class to define its own custom serialization format, giving full control over the process, unlike `Serializable` which uses default serialization.",
      "It automatically encrypts serialized data."
    ]
  },
  {
    "questionText": "What is the purpose of `Collectors.groupingBy()` in Java 8 Streams?",
    "correctAnswer": "To group elements of a stream into a `Map` based on a classification function, with optional downstream collectors for aggregate operations.",
    "explanation": "`groupingBy()` is a powerful collector that transforms a stream into a `Map`. The keys of the map are derived from the classification function, and the values are lists of elements belonging to that group (or a result of another downstream collector like `counting()`, `summingInt()`).",
    "options": [
      "To combine elements from multiple streams into one.",
      "To filter elements based on a condition.",
      "To group elements of a stream into a `Map` based on a classification function, with optional downstream collectors for aggregate operations.",
      "To sort elements within a stream."
    ]
  },
  {
    "questionText": "What is a **`Thread Dump`** and what information does it typically provide for debugging concurrency issues?",
    "correctAnswer": "A snapshot of all threads currently running in a JVM, showing their state (e.g., RUNNABLE, WAITING, BLOCKED) and stack traces, crucial for diagnosing deadlocks, livelocks, or performance bottlenecks.",
    "explanation": "A thread dump (generated by `jstack` or `kill -3 <pid>`) is invaluable for debugging. It reveals which threads are active, which are blocked (and on which lock), and their call stacks, helping to identify synchronized blocks, deadlocks, and other concurrency problems.",
    "options": [
      "A summary of all class loaded by the JVM.",
      "A log file of all network connections made by an application.",
      "A snapshot of all threads currently running in a JVM, showing their state (e.g., RUNNABLE, WAITING, BLOCKED) and stack traces, crucial for diagnosing deadlocks, livelocks, or performance bottlenecks.",
      "A record of all garbage collection cycles."
    ]
  },
  {
    "questionText": "Explain **`Generics Wildcard Capture`** in detail with an example.",
    "correctAnswer": "It's a compile-time mechanism where the compiler infers a concrete type for a wildcard. For `List<?> list`, if you try to `list.add(new Object())`, it's a compile-time error because `?` is captured as an unknown type (say `CAP#1`), and you can't add arbitrary objects to `List<CAP#1>`.",
    "explanation": "Wildcard capture is the compiler's way of dealing with wildcards. When you have `List<?> list`, the `?` is 'captured' as a specific, but unknown, type (e.g., `CAP#1`). You can read elements (which will be treated as `Object`), but you cannot add elements, because the compiler cannot ensure that the type you are adding matches the unknown captured type. This prevents heap pollution.",
    "options": [
      "It's a runtime error that occurs when a wildcard type is not handled.",
      "It allows adding any type of object to a generic collection.",
      "It's a compile-time mechanism where the compiler infers a concrete type for a wildcard. For `List<?> list`, if you try to `list.add(new Object())`, it's a compile-time error because `?` is captured as an unknown type (say `CAP#1`), and you can't add arbitrary objects to `List<CAP#1>`.",
      "It optimizes wildcard operations for better performance."
    ]
  },
  {
    "questionText": "What is the difference between `System.gc()` and running a garbage collector with JVM arguments (`-XX:+UseG1GC`, etc.)?",
    "correctAnswer": "`System.gc()` is merely a hint to the JVM to run the garbage collector, and it's not guaranteed to execute. JVM arguments configure the garbage collector's behavior and type.",
    "explanation": "`System.gc()` suggests to the JVM that garbage collection might be a good idea, but the JVM is free to ignore it. JVM arguments, on the other hand, explicitly configure which garbage collector to use (e.g., G1, CMS, ParallelGC) and their parameters, dictating the actual behavior.",
    "options": [
      "`System.gc()` performs a full GC; JVM arguments perform partial GC.",
      "JVM arguments trigger GC immediately; `System.gc()` delays it.",
      "`System.gc()` is merely a hint to the JVM to run the garbage collector, and it's not guaranteed to execute. JVM arguments configure the garbage collector's behavior and type.",
      "There is no difference; they achieve the same result."
    ]
  },
  {
    "questionText": "What is the concept of **`Value-based Classes`** (e.g., `Optional`, `LocalDateTime`) and why should they not be extended or used for synchronization?",
    "correctAnswer": "Classes that represent data, where equality is based on value, not identity. They should not be extended (implicitly final/sealed) or synchronized upon because their identity might not be stable, violating thread safety assumptions.",
    "explanation": "Value-based classes are meant to be treated as values, not mutable objects with a stable identity. The JVM can perform optimizations (e.g., caching, identity checks) on them. Extending them or using `synchronized(valueBasedObject)` on them can lead to unexpected behavior because their `hashCode()` or `equals()` might not be consistent with identity, breaking synchronization guarantees.",
    "options": [
      "Classes that only hold primitive data types.",
      "Classes that are always thread-safe by default.",
      "Classes that represent data, where equality is based on value, not identity. They should not be extended (implicitly final/sealed) or synchronized upon because their identity might not be stable, violating thread safety assumptions.",
      "Classes that are only used for database operations."
    ]
  },
  {
    "questionText": "What is **`BiFunction`** in Java 8's functional interfaces?",
    "correctAnswer": "An interface that represents a function that accepts two arguments and produces one result.",
    "explanation": "`BiFunction<T, U, R>` takes two input arguments of types `T` and `U` and returns a result of type `R`. It's part of `java.util.function` package.",
    "options": [
      "An interface that accepts one argument and returns two results.",
      "An interface that accepts two arguments and produces one result.",
      "An interface for binary operations on streams.",
      "An interface for comparing two objects."
    ]
  },
  {
    "questionText": "Explain the difference between **`Executor`** and **`ExecutorService`**.",
    "correctAnswer": "`Executor` is a simple interface for executing tasks, defining only the `execute(Runnable command)` method. `ExecutorService` extends `Executor`, adding lifecycle management (shutdown), `Future` support (`submit`), and batch task execution.",
    "explanation": "`Executor` provides a basic `fire-and-forget` mechanism for running tasks. `ExecutorService` offers a more comprehensive framework for managing thread pools and asynchronous task execution, including features like submitting `Callable` tasks, gracefully shutting down the pool, and managing the state of submitted tasks with `Future`.",
    "options": [
      "`Executor` is for single-threaded execution, `ExecutorService` for multi-threaded.",
      "`ExecutorService` is an abstract class, `Executor` is an interface.",
      "`Executor` is a simple interface for executing tasks, defining only the `execute(Runnable command)` method. `ExecutorService` extends `Executor`, adding lifecycle management (shutdown), `Future` support (`submit`), and batch task execution.",
      "`Executor` guarantees task completion, `ExecutorService` does not."
    ]
  },
  {
    "questionText": "What is the purpose of **`MethodHandles`** in Java 7+?",
    "correctAnswer": "To provide a more performant and flexible alternative to Java Reflection for dynamic method invocation, often used by dynamic languages on the JVM and internal frameworks.",
    "explanation": "`MethodHandles` provide a lower-level, type-safe, and more performant way to invoke methods or access fields dynamically compared to `java.lang.reflect`. They represent direct, type-safe, and optimizable pointers to methods, fields, or constructors.",
    "options": [
      "To manage concurrent access to shared resources.",
      "To create new classes at runtime.",
      "To provide a more performant and flexible alternative to Java Reflection for dynamic method invocation, often used by dynamic languages on the JVM and internal frameworks.",
      "To serialize objects to a byte stream."
    ]
  },
  {
    "questionText": "What is the concept of `Class Loader Delegation Model`?",
    "correctAnswer": "When a class loader needs to load a class, it first delegates the request to its parent class loader, and only attempts to load the class itself if the parent cannot find or load it.",
    "explanation": "This hierarchical model ensures that system classes are loaded by the bootstrap or extension class loader, preventing malicious code from replacing core Java classes. The order is: Bootstrap -> Extension -> System -> Custom. This provides security and consistency.",
    "options": [
      "It allows classes to be loaded from multiple sources simultaneously.",
      "It is a mechanism for pre-loading all required classes at application startup.",
      "When a class loader needs to load a class, it first delegates the request to its parent class loader, and only attempts to load the class itself if the parent cannot find or load it.",
      "It defines how classes are loaded into the permgen space."
    ]
  },
  {
    "questionText": "How does `PhantomReference` differ from `WeakReference` and `SoftReference` in terms of garbage collection and `ReferenceQueue` interaction?",
    "correctAnswer": "`PhantomReference`'s referent is added to its `ReferenceQueue` *after* finalization and only when it's phantom reachable, allowing for precise post-mortem cleanup. `Weak` and `Soft` are enqueued *before* finalization.",
    "explanation": "`PhantomReference` is the weakest type. Its key distinguishing feature is that its `get()` method always returns `null`. Its primary use is in conjunction with a `ReferenceQueue` to perform an action just before an object is completely removed from memory, indicating that the object is 'phantom reachable'.",
    "options": [
      "`PhantomReference` prevents garbage collection entirely.",
      "`WeakReference` and `SoftReference` are stronger than `PhantomReference`.",
      "`PhantomReference`'s referent is added to its `ReferenceQueue` *after* finalization and only when it's phantom reachable, allowing for precise post-mortem cleanup. `Weak` and `Soft` are enqueued *before* finalization.",
      "Only `PhantomReference` can be used with `ReferenceQueue`."
    ]
  },
  {
    "questionText": "What is **`Method Handles`** and how do they relate to `invokedynamic` instruction (Java 7+)?",
    "correctAnswer": "`Method Handles` are dynamically-typed, directly executable pointers to methods, fields, or constructors. They are the primary API for manipulating `invokedynamic` call sites, allowing for dynamic linking of methods at runtime.",
    "explanation": "`invokedynamic` is a new JVM instruction introduced to support dynamic languages (like Groovy, Scala) more efficiently. `Method Handles` provide the Java API to construct and manipulate call sites for `invokedynamic`, allowing for very flexible and efficient dynamic dispatch of method calls.",
    "options": [
      "`Method Handles` replace `Reflection` completely for all use cases.",
      "`invokedynamic` is used for static method calls only.",
      "`Method Handles` are dynamically-typed, directly executable pointers to methods, fields, or constructors. They are the primary API for manipulating `invokedynamic` call sites, allowing for dynamic linking of methods at runtime.",
      "They are only used internally by the JVM and cannot be used by application code."
    ]
  },
  {
    "questionText": "What is the concept of **`Escape Analysis`** in JVM optimization?",
    "correctAnswer": "A JVM optimization that determines if an object's scope is confined to a method or thread. If so, it might allocate the object on the stack instead of the heap (stack allocation) or even eliminate the allocation entirely (scalar replacement).",
    "explanation": "If the JVM can prove that an object (or parts of it) does not 'escape' its current method or thread, it can apply optimizations like stack allocation (faster, less GC pressure) or scalar replacement (breaking the object into its fields and storing them as primitives, eliminating the object allocation altogether).",
    "options": [
      "A security mechanism to prevent unauthorized access to objects.",
      "A static code analysis tool for detecting memory leaks.",
      "A JVM optimization that determines if an object's scope is confined to a method or thread. If so, it might allocate the object on the stack instead of the heap (stack allocation) or even eliminate the allocation entirely (scalar replacement).",
      "A technique for converting Java code to native machine code."
    ]
  },
  {
    "questionText": "What is the primary difference between `ForkJoinPool` and `ThreadPoolExecutor`?",
    "correctAnswer": "`ForkJoinPool` is designed for divide-and-conquer, recursive tasks with a work-stealing algorithm, while `ThreadPoolExecutor` is a general-purpose thread pool for executing independent tasks.",
    "explanation": "`ForkJoinPool` is optimized for tasks that recursively fork into subtasks and then join their results. It uses a work-stealing mechanism to keep all threads busy. `ThreadPoolExecutor` is more flexible for various task types (long-running, short-running, CPU-bound, I/O-bound) and provides more explicit control over queueing and rejection policies.",
    "options": [
      "`ForkJoinPool` creates new threads for every task.",
      "`ThreadPoolExecutor` is always faster for all types of tasks.",
      "`ForkJoinPool` is designed for divide-and-conquer, recursive tasks with a work-stealing algorithm, while `ThreadPoolExecutor` is a general-purpose thread pool for executing independent tasks.",
      "`ForkJoinPool` does not support `Callable` tasks."
    ]
  },
  {
    "questionText": "Explain the concept of **`Liveness`** vs. **`Safety`** in concurrent programming.",
    "correctAnswer": "`Safety` properties state that 'nothing bad ever happens' (e.g., no data corruption, no deadlocks). `Liveness` properties state that 'something good eventually happens' (e.g., a thread eventually executes, a task completes).",
    "explanation": "Safety ensures correctness of data and state (e.g., mutual exclusion, atomicity). Liveness ensures progress and responsiveness (e.g., threads eventually acquire locks, tasks complete, absence of starvation). Both are crucial for robust concurrent systems.",
    "options": [
      "`Liveness` refers to threads being alive, `Safety` to memory safety.",
      "`Safety` is about preventing errors, `Liveness` is about ensuring performance.",
      "`Safety` properties state that 'nothing bad ever happens' (e.g., no data corruption, no deadlocks). `Liveness` properties state that 'something good eventually happens' (e.g., a thread eventually executes, a task completes).",
      "`Liveness` is guaranteed if `Safety` is achieved."
    ]
  },
  {
    "questionText": "What is the `CompletableFuture.allOf()` method used for?",
    "correctAnswer": "To return a new `CompletableFuture` that is completed when all of the given `CompletableFuture`s complete (possibly with an exception).",
    "explanation": "`allOf()` is useful when you have multiple independent asynchronous computations and you want to perform an action only after all of them have finished, regardless of their individual results. It returns `CompletableFuture<Void>`.",
    "options": [
      "To combine the results of multiple `CompletableFuture`s into a single result.",
      "To execute multiple `CompletableFuture`s sequentially.",
      "To return a new `CompletableFuture` that is completed when all of the given `CompletableFuture`s complete (possibly with an exception).",
      "To cancel all active `CompletableFuture`s."
    ]
  },
  {
    "questionText": "What is the significance of the `transient` keyword in Java Serialization?",
    "correctAnswer": "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
    "explanation": "If a field is declared `transient`, its value will not be included in the serialized output. Upon deserialization, that field will revert to its default value (e.g., `null` for objects, `0` for numeric types). This is useful for sensitive data (passwords) or data that can be recomputed.",
    "options": [
      "It indicates that a field must be initialized at compile time.",
      "It makes a field volatile for thread safety.",
      "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
      "It allows a field to be modified from different threads."
    ]
  },
  {
    "questionText": "What is `StackOverflowError` and how is it typically caused in Java?",
    "correctAnswer": "An `Error` indicating that the application recursion depth is too large, leading to stack memory exhaustion, commonly caused by infinite recursion without a base case.",
    "explanation": "Each method call adds a frame to the call stack. Excessive method calls, especially in recursive functions without proper termination conditions, can exhaust the fixed-size stack memory, leading to this `Error`.",
    "options": [
      "A runtime exception indicating that the heap memory is full.",
      "A compile-time error when too many local variables are declared.",
      "An `Error` indicating that the application recursion depth is too large, leading to stack memory exhaustion, commonly caused by infinite recursion without a base case.",
      "An error caused by a deadlock between threads."
    ]
  },
  {
    "questionText": "What is the use case for the `ServiceLoader` API (Java SE 6+)?",
    "correctAnswer": "To dynamically discover and load implementations of a service interface at runtime, promoting extensibility and loose coupling (e.g., JDBC drivers, logging frameworks).",
    "explanation": "The `ServiceLoader` mechanism allows you to define an abstract service interface and then let different providers offer concrete implementations. Applications can then use `ServiceLoader` to find and load available implementations without compile-time knowledge of their concrete types. This is a core part of the 'Inversion of Control' principle.",
    "options": [
      "To perform static code analysis for security vulnerabilities.",
      "To compile Java source code into bytecode at runtime.",
      "To dynamically discover and load implementations of a service interface at runtime, promoting extensibility and loose coupling (e.g., JDBC drivers, logging frameworks).",
      "To manage distributed transactions across multiple databases."
    ]
  },
  {
    "questionText": "Explain **`Read-Write Lock`** vs. `synchronized` for concurrent data access.",
    "correctAnswer": "`Read-Write Lock` (e.g., `ReentrantReadWriteLock`) allows multiple readers or a single writer, optimizing for read-heavy scenarios. `synchronized` allows only one thread (reader or writer) to access the critical section at a time.",
    "explanation": "`synchronized` provides exclusive access, which can be a bottleneck for data structures that are mostly read. `ReentrantReadWriteLock` improves concurrency by allowing many readers to access the data simultaneously, but still ensuring that only one writer can access it, and no readers can access it while a writer is active.",
    "options": [
      "`synchronized` guarantees fairness, `Read-Write Lock` does not.",
      "`Read-Write Lock` is only for static methods.",
      "`Read-Write Lock` (e.g., `ReentrantReadWriteLock`) allows multiple readers or a single writer, optimizing for read-heavy scenarios. `synchronized` allows only one thread (reader or writer) to access the critical section at a time.",
      "`synchronized` is always faster for any access pattern."
    ]
  },
  {
    "questionText": "What is the primary difference between `CompletableFuture.thenApply()` and `CompletableFuture.thenCompose()`?",
    "correctAnswer": "`thenApply()` transforms the result of the previous `CompletableFuture` by applying a function that returns a plain value. `thenCompose()` transforms the result by applying a function that returns another `CompletableFuture`, effectively flattening nested futures.",
    "explanation": "`thenApply()` is used for synchronous transformations or when the transformation function returns a non-`CompletableFuture` value. `thenCompose()` is crucial for chaining asynchronous operations where the output of one future is the input for another future.",
    "options": [
      "`thenApply()` is synchronous, `thenCompose()` is asynchronous.",
      "`thenCompose()` can handle exceptions, `thenApply()` cannot.",
      "`thenApply()` transforms the result of the previous `CompletableFuture` by applying a function that returns a plain value. `thenCompose()` transforms the result by applying a function that returns another `CompletableFuture`, effectively flattening nested futures.",
      "There is no functional difference; they are aliases."
    ]
  },
  {
    "questionText": "What is a **`Thread Pool`** and what problem does it solve?",
    "correctAnswer": "A managed collection of worker threads that can execute submitted tasks. It solves the overhead of creating and destroying threads for each task and manages resource utilization.",
    "explanation": "Creating and destroying threads is expensive. A thread pool reuses threads, minimizing overhead. It also allows managing the number of concurrent threads, preventing resource exhaustion from too many active threads.",
    "options": [
      "A group of threads that always run sequentially.",
      "A mechanism to ensure all threads finish simultaneously.",
      "A managed collection of worker threads that can execute submitted tasks. It solves the overhead of creating and destroying threads for each task and manages resource utilization.",
      "A way to prioritize certain threads over others."
    ]
  },
  {
    "questionText": "Explain **`StampedLock`'s write lock** behavior.",
    "correctAnswer": "The write lock is exclusive, meaning no other thread (reader or writer) can acquire any lock while the write lock is held. It provides mutual exclusion for writes.",
    "explanation": "When a write lock is acquired, it blocks all readers (both optimistic and pessimistic) and other writers, ensuring complete isolation for modifications to the shared resource.",
    "options": [
      "Multiple writers can acquire the write lock concurrently.",
      "Readers can access the resource while a writer holds the lock.",
      "The write lock is exclusive, meaning no other thread (reader or writer) can acquire any lock while the write lock is held. It provides mutual exclusion for writes.",
      "The write lock can be downgraded to a read lock directly."
    ]
  },
  {
    "questionText": "What is `Heap Pollution` and how does `@SafeVarargs` relate to it?",
    "correctAnswer": "`Heap pollution` occurs when a variable of a parameterized type refers to an object that is not of that parameterized type. `@SafeVarargs` can suppress warnings for methods using varargs with non-reifiable types, indicating the developer has ensured type safety manually.",
    "explanation": "`@SafeVarargs` is an annotation that can be applied to methods or constructors with varargs to assert that the method does not perform operations that would lead to heap pollution. It suppresses unchecked warnings related to the varargs parameter.",
    "options": [
      "`Heap pollution` is a memory leak. `@SafeVarargs` prevents it.",
      "`@SafeVarargs` makes generic types reifiable at runtime.",
      "`Heap pollution` occurs when a variable of a parameterized type refers to an object that is not of that parameterized type. `@SafeVarargs` can suppress warnings for methods using varargs with non-reifiable types, indicating the developer has ensured type safety manually.",
      "`@SafeVarargs` allows any type to be passed to varargs methods."
    ]
  },
  {
    "questionText": "What is the primary benefit of `CompletableFuture` over raw `Future` and `ExecutorService`?",
    "correctAnswer": "`CompletableFuture` allows for asynchronous composition of tasks, fluent API for chaining operations, and better error handling, without explicit blocking or callbacks.",
    "explanation": "Raw `Future` requires blocking `get()` calls or manual polling. `CompletableFuture` (implementing `CompletionStage`) allows you to define a pipeline of asynchronous computations that react to completion or failures, leading to much cleaner and more expressive asynchronous code.",
    "options": [
      "`CompletableFuture` is always synchronous.",
      "`CompletableFuture` runs tasks on the main thread only.",
      "`CompletableFuture` allows for asynchronous composition of tasks, fluent API for chaining operations, and better error handling, without explicit blocking or callbacks.",
      "`CompletableFuture` automatically handles thread pool creation."
    ]
  },
  {
    "questionText": "When would you use `Callable` instead of `Runnable` for a task submitted to an `ExecutorService`?",
    "correctAnswer": "When the task needs to return a result or throw a checked exception.",
    "explanation": "`Runnable`'s `run()` method returns `void` and cannot throw checked exceptions. `Callable`'s `call()` method can return a result (which can be retrieved via a `Future`) and declare checked exceptions.",
    "options": [
      "When the task is very short-lived.",
      "When the task does not require synchronization.",
      "When the task needs to return a result or throw a checked exception.",
      "When the task needs to modify static variables."
    ]
  },
  {
    "questionText": "Explain **`Immutable Class`** design and its benefits in concurrent programming.",
    "correctAnswer": "A class whose objects cannot be modified after creation (all fields are `final` and `private`, no setters, defensive copies for mutable components). Benefits include inherent thread safety, easier reasoning about state, and suitability for caching/hashing.",
    "explanation": "Immutable objects are inherently thread-safe because their state cannot change after construction, eliminating race conditions. This simplifies concurrent programming significantly and makes them ideal for use as keys in maps or elements in sets.",
    "options": [
      "A class that cannot be extended.",
      "A class with only `static` methods.",
      "A class whose objects cannot be modified after creation (all fields are `final` and `private`, no setters, defensive copies for mutable components). Benefits include inherent thread safety, easier reasoning about state, and suitability for caching/hashing.",
      "A class that must be serialized."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "A hint to the JVM that the current thread is performing a spin loop, allowing the JVM/CPU to optimize accordingly (e.g., yield, pause instructions).",
    "explanation": "It's a low-level hint, typically used in highly optimized concurrent code or busy-waiting loops, to signal to the processor that the thread is busy-waiting. This can allow the CPU to save power or optimize resource usage, rather than blindly consuming cycles.",
    "options": [
      "To force a thread to sleep for a random duration.",
      "To prevent a thread from entering a blocked state.",
      "A hint to the JVM that the current thread is performing a spin loop, allowing the JVM/CPU to optimize accordingly (e.g., yield, pause instructions).",
      "To cause a thread to release its lock and wait."
    ]
  },
  {
    "questionText": "What is the concept of **`Value-based Classes`** (e.g., `Optional`, `LocalDateTime`) and why should they not be extended or used for synchronization?",
    "correctAnswer": "Classes that represent data, where equality is based on value, not identity. They should not be extended (implicitly final/sealed) or synchronized upon because their identity might not be stable, violating thread safety assumptions.",
    "explanation": "Value-based classes are meant to be treated as values, not mutable objects with a stable identity. The JVM can perform optimizations (e.g., caching, identity checks) on them. Extending them or using `synchronized(valueBasedObject)` on them can lead to unexpected behavior because their `hashCode()` or `equals()` might not be consistent with identity, breaking synchronization guarantees.",
    "options": [
      "Classes that only hold primitive data types.",
      "Classes that are always thread-safe by default.",
      "Classes that represent data, where equality is based on value, not identity. They should not be extended (implicitly final/sealed) or synchronized upon because their identity might not be stable, violating thread safety assumptions.",
      "Classes that are only used for database operations."
    ]
  },
  {
    "questionText": "What is `Thread.yield()` and how does it differ from `Thread.sleep(0)`?",
    "correctAnswer": "`Thread.yield()` is a hint to the scheduler that the current thread is willing to relinquish its CPU usage, but it does not guarantee a context switch. `Thread.sleep(0)` is also a hint that causes the current thread to pause and immediately re-enter the runnable state, essentially allowing the scheduler to pick another thread of the same or higher priority.",
    "explanation": "Both are weak hints. `yield()` basically says 'I'm done for now, someone else can run'. `sleep(0)` forces the thread to yield to other threads of equal or higher priority, effectively giving the scheduler a chance to re-evaluate thread priorities. `sleep(0)` is generally more reliable in causing a context switch than `yield()`.",
    "options": [
      "`yield()` causes the thread to block, `sleep(0)` does not.",
      "`sleep(0)` throws `InterruptedException`, `yield()` does not.",
      "`Thread.yield()` is a hint to the scheduler that the current thread is willing to relinquish its CPU usage, but it does not guarantee a context switch. `Thread.sleep(0)` is also a hint that causes the current thread to pause and immediately re-enter the runnable state, essentially allowing the scheduler to pick another thread of the same or higher priority.",
      "`yield()` is for static methods, `sleep(0)` for instance methods."
    ]
  },
  {
    "questionText": "What is a **`Memory Segment`** and **`MemoryAddress`** (Java 17+)?",
    "correctAnswer": "Part of the Foreign Function & Memory API (FFM API), `MemorySegment` represents a contiguous region of memory (on or off-heap), and `MemoryAddress` represents a specific point within that segment, allowing safe and efficient access to native memory.",
    "explanation": "The FFM API (`jdk.incubator.foreign`) provides a safe and efficient way for Java programs to interact with code and data outside the JVM. `MemorySegment` is a key abstraction for handling off-heap memory, replacing the unsafe `ByteBuffer.allocateDirect()` for better security and management.",
    "options": [
      "Primitives used to track heap memory allocation.",
      "Internal JVM structures for garbage collection.",
      "Part of the Foreign Function & Memory API (FFM API), `MemorySegment` represents a contiguous region of memory (on or off-heap), and `MemoryAddress` represents a specific point within that segment, allowing safe and efficient access to native memory.",
      "Used for defining custom memory allocation strategies within the JVM."
    ]
  },
  {
    "questionText": "What is `Serialization Proxy Pattern` and why is it used?",
    "correctAnswer": "A serialization pattern where a `Serializable` class defines a private nested `readResolve()` and a private `writeReplace()` method that returns a `SerializationProxy` object, which then handles the actual serialization/deserialization.",
    "explanation": "This pattern provides a robust way to control the serialization form of a class, especially for immutable classes or singletons. It helps prevent instances of inner classes from being serialized, enforces singleton property during deserialization, and provides a concise way to validate object state upon deserialization.",
    "options": [
      "A pattern to create temporary, non-serializable objects.",
      "A pattern for encrypting serialized data.",
      "A serialization pattern where a `Serializable` class defines a private nested `readResolve()` and a private `writeReplace()` method that returns a `SerializationProxy` object, which then handles the actual serialization/deserialization.",
      "A pattern that makes serialization faster for large objects."
    ]
  },
  {
    "questionText": "What is the purpose of **`StampedLock`** and how does it achieve optimistic reading?",
    "correctAnswer": "`StampedLock` provides a read-write lock that supports optimistic reading. An optimistic read acquires a 'stamp' without blocking, reads the data, and then `validate()`s the stamp. If validation fails, a pessimistic read lock must be acquired.",
    "explanation": "Optimistic reading allows readers to proceed without blocking writers. The `validate()` step checks if any writer modified the resource during the optimistic read. If it did, the optimistic read is invalidated, and the reader must fall back to a full pessimistic read lock to ensure data consistency.",
    "options": [
      "It's a simplified version of `synchronized` for basic locks.",
      "It only allows one reader at a time for better performance.",
      "`StampedLock` provides a read-write lock that supports optimistic reading. An optimistic read acquires a 'stamp' without blocking, reads the data, and then `validate()`s the stamp. If validation fails, a pessimistic read lock must be acquired.",
      "It is a lock designed specifically for `static` methods."
    ]
  },
  {
    "questionText": "What is a **`PermGen` `OutOfMemoryError`** and why is it less common in Java 8 and later?",
    "correctAnswer": "`PermGen` was a fixed-size memory area (pre-Java 8) for class metadata and interned strings. It's less common now because Java 8 replaced it with `Metaspace`, which is in native memory and can grow dynamically.",
    "explanation": "Before Java 8, `PermGen` (Permanent Generation) was part of the heap, with a fixed maximum size. Running out of `PermGen` space was a common issue in applications with many classes or dynamic class loading. `Metaspace` uses native memory, and its size can expand, significantly reducing `OutOfMemoryError` for class metadata.",
    "options": [
      "It's an error caused by too many threads.",
      "It signifies that the application's heap memory is exhausted.",
      "`PermGen` was a fixed-size memory area (pre-Java 8) for class metadata and interned strings. It's less common now because Java 8 replaced it with `Metaspace`, which is in native memory and can grow dynamically.",
      "It is a security vulnerability in the JVM."
    ]
  },
  {
    "questionText": "Explain the concept of **`Thread Interference`** and how `synchronized` helps prevent it.",
    "correctAnswer": "`Thread interference` occurs when multiple threads access and modify the same shared data concurrently without proper synchronization, leading to inconsistent or incorrect results. `synchronized` ensures atomic access to critical sections, preventing interference.",
    "explanation": "When threads operate on shared data without proper synchronization, the order of operations can be arbitrary, leading to race conditions. `synchronized` blocks or methods ensure that only one thread can execute a critical section at a time, preventing this interference and ensuring data consistency.",
    "options": [
      "When a thread blocks another thread from starting.",
      "When threads run on different CPU cores.",
      "`Thread interference` occurs when multiple threads access and modify the same shared data concurrently without proper synchronization, leading to inconsistent or incorrect results. `synchronized` ensures atomic access to critical sections, preventing interference.",
      "When threads communicate using network sockets."
    ]
  },
  {
    "questionText": "What is the purpose of the `invokeExact()` method in `MethodHandles` compared to `invoke()`?",
    "correctAnswer": "`invokeExact()` requires an exact signature match (including return type) at the call site, providing higher performance. `invoke()` performs signature polymorphism, allowing argument type conversions at runtime but with some overhead.",
    "explanation": "`invokeExact()` is stricter and faster as it avoids any runtime argument conversions. `invoke()` is more flexible, performing implicit boxing/unboxing, widening conversions, etc., if the method handle is 'signature polymorphic'.",
    "options": [
      "`invokeExact()` is for static methods, `invoke()` for instance methods.",
      "`invoke()` is for private methods, `invokeExact()` for public.",
      "`invokeExact()` requires an exact signature match (including return type) at the call site, providing higher performance. `invoke()` performs signature polymorphism, allowing argument type conversions at runtime but with some overhead.",
      "There is no performance difference."
    ]
  },
  {
    "questionText": "What is a **`Record`** in Java (introduced as preview in Java 14, standard in 16)?",
    "correctAnswer": "A concise syntax for declaring immutable data classes, automatically generating a canonical constructor, accessor methods, `equals()`, `hashCode()`, and `toString()`, and they are implicitly final.",
    "explanation": "Records aim to reduce boilerplate code for simple data-carrying classes. They are implicitly `final`, and components are implicitly `final` and `private`. They are ideal for representing simple tuples or DTOs where state is primary.",
    "options": [
      "A class that can only contain static methods.",
      "A class that implements multiple interfaces.",
      "A concise syntax for declaring immutable data classes, automatically generating a canonical constructor, accessor methods, `equals()`, `hashCode()`, and `toString()`, and they are implicitly final.",
      "A mechanism for defining database schemas."
    ]
  },
  {
    "questionText": "Explain the concept of **`Loom (Project Loom)`** and its goal.",
    "correctAnswer": "Project Loom aims to introduce 'Virtual Threads' (or Fibers) to Java, enabling vastly more concurrent lightweight threads than traditional platform threads, simplifying asynchronous programming and improving resource utilization for high-throughput applications.",
    "explanation": "Virtual threads are a lightweight implementation of threads that are scheduled by the JVM, not the OS. This allows a Java application to scale to millions of concurrent tasks without the overhead of traditional OS threads, making it easier to write high-throughput concurrent code without complex reactive frameworks.",
    "options": [
      "A new garbage collection algorithm.",
      "A framework for building microservices.",
      "Project Loom aims to introduce 'Virtual Threads' (or Fibers) to Java, enabling vastly more concurrent lightweight threads than traditional platform threads, simplifying asynchronous programming and improving resource utilization for high-throughput applications.",
      "A tool for static code analysis."
    ]
  },
  {
    "questionText": "What is **`BiFunction`** in Java 8's functional interfaces?",
    "correctAnswer": "An interface that represents a function that accepts two arguments and produces one result.",
    "explanation": "`BiFunction<T, U, R>` takes two input arguments of types `T` and `U` and returns a result of type `R`. It's part of `java.util.function` package.",
    "options": [
      "An interface that accepts one argument and returns two results.",
      "An interface that accepts two arguments and produces one result.",
      "An interface for binary operations on streams.",
      "An interface for comparing two objects."
    ]
  },
  {
    "questionText": "What is the primary difference between a `class` and an `interface` in Java (post-Java 8)?",
    "correctAnswer": "`Classes` can be instantiated, have constructors, and can hold instance state and concrete implementations. `Interfaces` cannot be instantiated (typically), represent contracts, can have `default` and `static` methods, but cannot hold instance state.",
    "explanation": "While Java 8+ interfaces can have concrete methods (`default` and `static`), they still cannot have constructors or instance variables. They fundamentally define a contract of behavior, whereas classes define both behavior and state of objects.",
    "options": [
      "Interfaces can have abstract methods, classes cannot.",
      "Classes can implement multiple interfaces, but interfaces can only extend one class.",
      "`Classes` can be instantiated, have constructors, and can hold instance state and concrete implementations. `Interfaces` cannot be instantiated (typically), represent contracts, can have `default` and `static` methods, but cannot hold instance state.",
      "Interfaces allow multiple inheritance of implementation, classes do not."
    ]
  },
  {
    "questionText": "What is the significance of `Optional.map()` vs. `Optional.flatMap()`?",
    "correctAnswer": "`map()` applies a function to the `Optional`'s value if present, and the function returns a non-`Optional` value. `flatMap()` applies a function that returns an `Optional` itself, effectively flattening nested `Optional`s.",
    "explanation": "`map()` is for transforming the value inside an `Optional`. If your mapping function itself returns an `Optional`, `flatMap()` is used to prevent ending up with `Optional<Optional<T>>`.",
    "options": [
      "`map()` is for synchronous operations, `flatMap()` for asynchronous.",
      "`flatMap()` can handle `null` values, `map()` cannot.",
      "`map()` applies a function to the `Optional`'s value if present, and the function returns a non-`Optional` value. `flatMap()` applies a function that returns an `Optional` itself, effectively flattening nested `Optional`s.",
      "There is no functional difference; they are aliases."
    ]
  },
  {
    "questionText": "What is the purpose of a **`Read-Write Lock`** (`ReentrantReadWriteLock`) in Java concurrency?",
    "correctAnswer": "To allow multiple threads to read a shared resource concurrently, but only permit one thread to write to it exclusively.",
    "explanation": "This type of lock improves concurrency for data structures that are frequently read but rarely written. Multiple readers can hold the read lock simultaneously, but the write lock is exclusive, blocking all readers and other writers.",
    "options": [
      "To prevent all concurrent access to a resource.",
      "To prioritize write operations over read operations.",
      "To allow multiple threads to read a shared resource concurrently, but only permit one thread to write to it exclusively.",
      "To ensure that only one thread can access a resource at any time."
    ]
  },
  {
    "questionText": "What is `BiConsumer` and `Consumer` in `java.util.function`?",
    "correctAnswer": "`Consumer` accepts one input argument and returns no result. `BiConsumer` accepts two input arguments and returns no result.",
    "explanation": "Both are functional interfaces representing operations that 'consume' input arguments without producing a return value. `Consumer` is for single inputs, `BiConsumer` for two.",
    "options": [
      "Both return a boolean value.",
      "`Consumer` is for static methods, `BiConsumer` for instance methods.",
      "`Consumer` accepts one input argument and returns no result. `BiConsumer` accepts two input arguments and returns no result.",
      "They are used for stream reductions only."
    ]
  },
  {
    "questionText": "What is the concept of **`ReentrantLock` fairness**?",
    "correctAnswer": "A `ReentrantLock` can be configured as 'fair', meaning that if multiple threads are waiting for the lock, the longest-waiting thread will be granted the lock next. Unfair locks do not guarantee this order.",
    "explanation": "Fairness comes with a performance cost. Unfair locks generally perform better because they allow 'hand-off' locking (a newly released lock can be immediately re-acquired by the thread that just released it, or a newly arriving thread can 'cut in line'). Fair locks ensure that threads waiting the longest acquire the lock.",
    "options": [
      "It ensures that a lock is always released after a fixed time.",
      "It prevents deadlocks in multi-threaded applications.",
      "A `ReentrantLock` can be configured as 'fair', meaning that if multiple threads are waiting for the lock, the longest-waiting thread will be granted the lock next. Unfair locks do not guarantee this order.",
      "It allows a thread to re-acquire the same lock multiple times."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the consequence of not overriding `hashCode()` when `equals()` is overridden, especially in collections?",
    "correctAnswer": "Hash-based collections (like `HashMap`, `HashSet`) will not work correctly, as objects that are equal by `equals()` may have different hash codes and thus be stored in different buckets.",
    "explanation": "The contract between `equals()` and `hashCode()` states that if two objects are `equals()`, their `hashCode()` must be the same. Failing to uphold this means `HashSet` might store duplicates, or `HashMap` might fail to find an object that was `put()` into it.",
    "options": [
      "A compile-time error will occur.",
      "It will only affect `TreeSet` and `TreeMap`.",
      "Hash-based collections (like `HashMap`, `HashSet`) will not work correctly, as objects that are equal by `equals()` may have different hash codes and thus be stored in different buckets.",
      "The program will run slower but without functional errors."
    ]
  },
  {
    "questionText": "What is the primary difference between a `BlockingQueue` and a `ConcurrentLinkedQueue`?",
    "correctAnswer": "`BlockingQueue` provides blocking operations (`put()`, `take()`) for when the queue is full or empty, making it ideal for producer-consumer scenarios. `ConcurrentLinkedQueue` is a non-blocking, thread-safe queue.",
    "explanation": "`BlockingQueue` is designed for bounded scenarios where producers need to wait if the queue is full, and consumers need to wait if it's empty. `ConcurrentLinkedQueue` is an unbounded, non-blocking queue that uses a lock-free algorithm for high concurrency, but operations like `add()` or `poll()` will not block.",
    "options": [
      "`BlockingQueue` is always sorted.",
      "`ConcurrentLinkedQueue` is not thread-safe.",
      "`BlockingQueue` provides blocking operations (`put()`, `take()`) for when the queue is full or empty, making it ideal for producer-consumer scenarios. `ConcurrentLinkedQueue` is a non-blocking, thread-safe queue.",
      "`ConcurrentLinkedQueue` uses more memory than `BlockingQueue`."
    ]
  },
  {
    "questionText": "Explain the concept of **`Reified Generics`** and why Java doesn't fully support them.",
    "correctAnswer": "`Reified generics` mean that generic type information is available at runtime. Java uses `Type Erasure` for backward compatibility, meaning generic type parameters are removed during compilation, making them `non-reifiable`.",
    "explanation": "Java's generics are implemented via type erasure for backward compatibility with pre-generics code. This means that at runtime, generic type information (like `String` in `List<String>`) is lost. Some languages on the JVM (like Scala) support reified generics at a language level, but Java's core implementation does not.",
    "options": [
      "`Reified generics` are only for primitive types.",
      "Java fully supports reified generics since Java 5.",
      "`Reified generics` mean that generic type information is available at runtime. Java uses `Type Erasure` for backward compatibility, meaning generic type parameters are removed during compilation, making them `non-reifiable`.",
      "They are used to create dynamic proxies."
    ]
  },
  {
    "questionText": "What is the purpose of the `volatile` keyword in Java memory model?",
    "correctAnswer": "It ensures visibility of changes to a variable across different threads and prevents instruction reordering for that variable.",
    "explanation": "A `volatile` variable acts as a memory barrier: all writes to a volatile variable `happens-before` any subsequent reads of that same volatile variable by any thread. This prevents a thread from seeing stale data from its local cache.",
    "options": [
      "It locks the variable for exclusive access by one thread.",
      "It makes the variable immutable.",
      "It ensures visibility of changes to a variable across different threads and prevents instruction reordering for that variable.",
      "It makes the variable eligible for garbage collection faster."
    ]
  },
  {
    "questionText": "What is `ThreadLocalRandom` (Java 7+) and why is it preferred over `Random` in multi-threaded contexts?",
    "correctAnswer": "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
    "explanation": "Instances of `java.util.Random` are thread-safe but may suffer from contention in highly concurrent environments because multiple threads try to update the same seed. `ThreadLocalRandom` avoids this by giving each thread its own `Random` instance, eliminating contention and improving performance.",
    "options": [
      "It generates truly random numbers.",
      "It is a legacy class for backward compatibility.",
      "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
      "It uses a larger seed for more randomness."
    ]
  },
  {
    "questionText": "Explain **`BiConsumer`** in Java 8's functional interfaces.",
    "correctAnswer": "An interface that represents an operation that accepts two input arguments and returns no result.",
    "explanation": "A `BiConsumer<T, U>` is a functional interface that takes two arguments (of types `T` and `U`) and performs an action, without returning any value. It's often used in `forEach` or `Map.forEach` operations.",
    "options": [
      "An interface that consumes two streams and produces one.",
      "An interface that returns two results.",
      "An interface that represents an operation that accepts two input arguments and returns no result.",
      "An interface for combining two functions."
    ]
  },
  {
    "questionText": "What is the concept of `Bi-directional Relationship` in JPA/Hibernate, and what is the common pitfall with it?",
    "correctAnswer": "When two entities reference each other, establishing a link in both directions. The common pitfall is managing both sides of the relationship consistently to avoid infinite loops or synchronization issues.",
    "explanation": "For example, a `User` has `List<Address>` and `Address` has a `User`. The pitfall lies in ensuring that when you add an address to a user, you also set the user on the address and vice-versa, especially during persistence to avoid orphaned records or unintended behavior like infinite loops in `toString()` or `equals()/hashCode()`.",
    "options": [
      "When an entity can be accessed from two different tables.",
      "When a single entity class has two primary keys.",
      "When two entities reference each other, establishing a link in both directions. The common pitfall is managing both sides of the relationship consistently to avoid infinite loops or synchronization issues.",
      "When an entity can be saved to two different databases."
    ]
  },
  {
    "questionText": "What is the difference between a `Checked Exception` and an `Unchecked Exception` in Java?",
    "correctAnswer": "Checked exceptions must be declared (using `throws`) or caught (using `try-catch`) at compile time. Unchecked exceptions (subclasses of `RuntimeException` and `Error`) do not require explicit handling and typically indicate programming errors.",
    "explanation": "Checked exceptions (e.g., `IOException`, `SQLException`) are part of a method's signature and must be handled by the caller. Unchecked exceptions (e.g., `NullPointerException`, `ArrayIndexOutOfBoundsException`) are usually preventable by better coding and do not force handling, though they can be caught.",
    "options": [
      "Checked exceptions occur at runtime, unchecked at compile time.",
      "Checked exceptions are always fatal, unchecked exceptions are not.",
      "Checked exceptions must be declared (using `throws`) or caught (using `try-catch`) at compile time. Unchecked exceptions (subclasses of `RuntimeException` and `Error`) do not require explicit handling and typically indicate programming errors.",
      "Unchecked exceptions can be rethrown, checked exceptions cannot."
    ]
  },
  {
    "questionText": "Explain the concept of **`Reified Generics`** and why Java doesn't fully support them.",
    "correctAnswer": "`Reified generics` mean that generic type information is available at runtime. Java uses `Type Erasure` for backward compatibility, meaning generic type parameters are removed during compilation, making them `non-reifiable`.",
    "explanation": "Java's generics are implemented via type erasure for backward compatibility with pre-generics code. This means that at runtime, generic type information (like `String` in `List<String>`) is lost. Some languages on the JVM (like Scala) support reified generics at a language level, but Java's core implementation does not.",
    "options": [
      "`Reified generics` are only for primitive types.",
      "Java fully supports reified generics since Java 5.",
      "`Reified generics` mean that generic type information is available at runtime. Java uses `Type Erasure` for backward compatibility, meaning generic type parameters are removed during compilation, making them `non-reifiable`.",
      "They are used to create dynamic proxies."
    ]
  },
  {
    "questionText": "What is the purpose of a `CompletionStage` in Java 8+ concurrency?",
    "correctAnswer": "It represents a stage in an asynchronous computation that can be composed with other stages, allowing for sequential or parallel execution and handling of results and exceptions.",
    "explanation": "`CompletionStage` is an interface implemented by `CompletableFuture`. It defines a set of methods for attaching actions to a completed stage (e.g., `thenApply`, `thenAccept`, `thenCompose`), enabling fluent, non-blocking programming for asynchronous workflows.",
    "options": [
      "To define the final state of a completed thread.",
      "To mark a method as requiring exclusive access.",
      "It represents a stage in an asynchronous computation that can be composed with other stages, allowing for sequential or parallel execution and handling of results and exceptions.",
      "To manage a fixed number of threads in a pool."
    ]
  },
  {
    "questionText": "What is the primary motivation for introducing **`Sealed Classes`** in Java (preview in Java 15, standard in 17)?",
    "correctAnswer": "To restrict which classes or interfaces can directly extend or implement a class/interface, providing more control over inheritance hierarchies and enabling exhaustive pattern matching.",
    "explanation": "Sealed classes/interfaces explicitly declare which other classes/interfaces are permitted to extend/implement them using the `permits` keyword. This enhances encapsulation and supports future language features like exhaustive `switch` expressions/statements (pattern matching).",
    "options": [
      "To prevent a class from being garbage collected.",
      "To make all methods in a class final.",
      "To restrict which classes or interfaces can directly extend or implement a class/interface, providing more control over inheritance hierarchies and enabling exhaustive pattern matching.",
      "To automatically generate boilerplate code for data classes."
    ]
  },
  {
    "questionText": "Explain the concept of `Lock Convoy` in multithreading.",
    "correctAnswer": "A performance bottleneck where threads repeatedly contend for a lock, leading to inefficient context switching and reduced throughput, often caused by frequent, short lock acquisitions.",
    "explanation": "A lock convoy occurs when many threads repeatedly try to acquire the same lock. This leads to thrashing as the OS constantly performs context switches, moving threads to and from the runnable queue, resulting in significant overhead and poor performance, even if the critical section itself is very small.",
    "options": [
      "When a single thread acquires all available locks.",
      "A situation where threads collaborate to acquire a complex lock.",
      "A performance bottleneck where threads repeatedly contend for a lock, leading to inefficient context switching and reduced throughput, often caused by frequent, short lock acquisitions.",
      "When a lock is held for an excessively long period."
    ]
  },
  {
    "questionText": "What is the difference between `Stream.forEach()` and `Collection.forEach()`?",
    "correctAnswer": "`Stream.forEach()` is a terminal stream operation that may execute in parallel and does not guarantee encounter order. `Collection.forEach()` is a default method on `Iterable` that iterates sequentially and preserves encounter order.",
    "explanation": "`Stream.forEach()` is part of the `Stream` API, designed for processing data in a pipeline, and its execution order for parallel streams is not guaranteed. `Collection.forEach()` (inherited from `Iterable`) is a more convenient way to iterate over collections sequentially, similar to an enhanced `for` loop.",
    "options": [
      "`Stream.forEach()` can modify the underlying collection; `Collection.forEach()` cannot.",
      "`Collection.forEach()` is faster for large datasets.",
      "`Stream.forEach()` is a terminal stream operation that may execute in parallel and does not guarantee encounter order. `Collection.forEach()` is a default method on `Iterable` that iterates sequentially and preserves encounter order.",
      "There is no functional difference; they are aliases."
    ]
  },
  {
    "questionText": "What is the purpose of `WeakHashMap` and how does it affect garbage collection?",
    "correctAnswer": "Keys in a `WeakHashMap` are held using weak references. If a key object is not strongly referenced elsewhere, its entry in the map can be garbage collected, preventing memory leaks for temporary keys.",
    "explanation": "`WeakHashMap` is used when you want the map to automatically discard entries once their keys are no longer strongly referenced by other parts of the application. This helps in managing memory for caches where entries should expire if their keys are no longer in use.",
    "options": [
      "It prevents garbage collection of its keys.",
      "It provides a synchronized version of `HashMap`.",
      "Keys in a `WeakHashMap` are held using weak references. If a key object is not strongly referenced elsewhere, its entry in the map can be garbage collected, preventing memory leaks for temporary keys.",
      "Values in a `WeakHashMap` are automatically removed after a timeout."
    ]
  },
  {
    "questionText": "What is a **`PermGen` `OutOfMemoryError`** and why is it less common in Java 8 and later?",
    "correctAnswer": "`PermGen` was a fixed-size memory area (pre-Java 8) for class metadata and interned strings. It's less common now because Java 8 replaced it with `Metaspace`, which is in native memory and can grow dynamically.",
    "explanation": "Before Java 8, `PermGen` (Permanent Generation) was part of the heap, with a fixed maximum size. Running out of `PermGen` space was a common issue in applications with many classes or dynamic class loading. `Metaspace` uses native memory, and its size can expand, significantly reducing `OutOfMemoryError` for class metadata.",
    "options": [
      "It's an error caused by too many threads.",
      "It signifies that the application's heap memory is exhausted.",
      "`PermGen` was a fixed-size memory area (pre-Java 8) for class metadata and interned strings. It's less common now because Java 8 replaced it with `Metaspace`, which is in native memory and can grow dynamically.",
      "It is a security vulnerability in the JVM."
    ]
  },
  {
    "questionText": "What is the significance of the `transient` keyword in Java Serialization?",
    "correctAnswer": "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
    "explanation": "If a field is declared `transient`, its value will not be included in the serialized output. Upon deserialization, that field will revert to its default value (e.g., `null` for objects, `0` for numeric types). This is useful for sensitive data (passwords) or data that can be recomputed.",
    "options": [
      "It indicates that a field must be initialized at compile time.",
      "It makes a field volatile for thread safety.",
      "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
      "It allows a field to be modified from different threads."
    ]
  },
  {
    "questionText": "Explain the concept of `Bounded Wildcards` in Java Generics (e.g., `<? extends T>`, `<? super T>`).",
    "correctAnswer": "`<? extends T>` (upper bound) means a collection of `T` or any subtype of `T` (producer: you can read `T`s out). `<? super T>` (lower bound) means a collection of `T` or any supertype of `T` (consumer: you can write `T`s into it).",
    "explanation": "PECS (Producer-`extends`, Consumer-`super`) is the mnemonic. `? extends T` is used when the generic type will produce values that are of type `T` or a subtype. `? super T` is used when the generic type will consume values that are of type `T` or a supertype. This provides flexibility while maintaining type safety.",
    "options": [
      "They allow a generic type to be assigned multiple specific types.",
      "They restrict a generic type to be either a class or an interface.",
      "`<? extends T>` (upper bound) means a collection of `T` or any subtype of `T` (producer: you can read `T`s out). `<? super T>` (lower bound) means a collection of `T` or any supertype of `T` (consumer: you can write `T`s into it).",
      "They are used for defining type parameters in method signatures only."
    ]
  },
  {
    "questionText": "What is `ThreadLocalRandom` (Java 7+), and why is it preferred over `Random` in multi-threaded contexts?",
    "correctAnswer": "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
    "explanation": "Instances of `java.util.Random` are thread-safe but may suffer from contention in highly concurrent environments because multiple threads try to update the same seed. `ThreadLocalRandom` avoids this by giving each thread its own `Random` instance, eliminating contention and improving performance.",
    "options": [
      "It generates truly random numbers.",
      "It is a legacy class for backward compatibility.",
      "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
      "It uses a larger seed for more randomness."
    ]
  },
  {
    "questionText": "What is the purpose of the `volatile` keyword in Java memory model?",
    "correctAnswer": "It ensures visibility of changes to a variable across different threads and prevents instruction reordering for that variable.",
    "explanation": "A `volatile` variable acts as a memory barrier: all writes to a volatile variable `happens-before` any subsequent reads of that same volatile variable by any thread. This prevents a thread from seeing stale data from its local cache.",
    "options": [
      "It locks the variable for exclusive access by one thread.",
      "It makes the variable immutable.",
      "It ensures visibility of changes to a variable across different threads and prevents instruction reordering for that variable.",
      "It makes the variable eligible for garbage collection faster."
    ]
  },
  {
    "questionText": "What is the concept of **`Value-based Classes`** (e.g., `Optional`, `LocalDateTime`) and why should they not be extended or used for synchronization?",
    "correctAnswer": "Classes that represent data, where equality is based on value, not identity. They should not be extended (implicitly final/sealed) or synchronized upon because their identity might not be stable, violating thread safety assumptions.",
    "explanation": "Value-based classes are meant to be treated as values, not mutable objects with a stable identity. The JVM can perform optimizations (e.g., caching, identity checks) on them. Extending them or using `synchronized(valueBasedObject)` on them can lead to unexpected behavior because their `hashCode()` or `equals()` might not be consistent with identity, breaking synchronization guarantees.",
    "options": [
      "Classes that only hold primitive data types.",
      "Classes that are always thread-safe by default.",
      "Classes that represent data, where equality is based on value, not identity. They should not be extended (implicitly final/sealed) or synchronized upon because their identity might not be stable, violating thread safety assumptions.",
      "Classes that are only used for database operations."
    ]
  },
  {
    "questionText": "What is the primary motivation for introducing `Sealed Classes` in Java (preview in Java 15, standard in 17)?",
    "correctAnswer": "To restrict which classes or interfaces can directly extend or implement a class/interface, providing more control over inheritance hierarchies and enabling exhaustive pattern matching.",
    "explanation": "Sealed classes/interfaces explicitly declare which other classes/interfaces are permitted to extend/implement them using the `permits` keyword. This enhances encapsulation and supports future language features like exhaustive `switch` expressions/statements (pattern matching).",
    "options": [
      "To prevent a class from being garbage collected.",
      "To make all methods in a class final.",
      "To restrict which classes or interfaces can directly extend or implement a class/interface, providing more control over inheritance hierarchies and enabling exhaustive pattern matching.",
      "To automatically generate boilerplate code for data classes."
    ]
  },
  {
    "questionText": "What is `Thread.yield()` and how does it differ from `Thread.sleep(0)`?",
    "correctAnswer": "`Thread.yield()` is a hint to the scheduler that the current thread is willing to relinquish its CPU usage, but it does not guarantee a context switch. `Thread.sleep(0)` is also a hint that causes the current thread to pause and immediately re-enter the runnable state, essentially allowing the scheduler to pick another thread of the same or higher priority.",
    "explanation": "Both are weak hints. `yield()` basically says 'I'm done for now, someone else can run'. `sleep(0)` forces the thread to yield to other threads of equal or higher priority, effectively giving the scheduler a chance to re-evaluate thread priorities. `sleep(0)` is generally more reliable in causing a context switch than `yield()`.",
    "options": [
      "`yield()` causes the thread to block, `sleep(0)` does not.",
      "`sleep(0)` throws `InterruptedException`, `yield()` does not.",
      "`Thread.yield()` is a hint to the scheduler that the current thread is willing to relinquish its CPU usage, but it does not guarantee a context switch. `Thread.sleep(0)` is also a hint that causes the current thread to pause and immediately re-enter the runnable state, essentially allowing the scheduler to pick another thread of the same or higher priority.",
      "`yield()` is for static methods, `sleep(0)` for instance methods."
    ]
  },
  {
    "questionText": "What is the purpose of **`StampedLock`'s optimistic read lock**?",
    "correctAnswer": "It's a non-blocking read operation that doesn't acquire a lock. It returns a 'stamp' that must be validated later to ensure no write operation occurred during the read.",
    "explanation": "An optimistic read doesn't block writers, making it very performant for read-heavy scenarios. You get a `stamp` before reading, read the data, then `validate()` the stamp. If `validate()` returns `false`, a write occurred, and you must acquire a pessimistic read lock or retry the optimistic read.",
    "options": [
      "It's a read lock that can be acquired by only one reader at a time.",
      "It's a read lock that prioritizes writers.",
      "It's a non-blocking read operation that doesn't acquire a lock. It returns a 'stamp' that must be validated later to ensure no write operation occurred during the read.",
      "It allows both reading and writing concurrently without any locking."
    ]
  },
  {
    "questionText": "Explain the concept of **`BiConsumer`** in Java 8's functional interfaces.",
    "correctAnswer": "An interface that represents an operation that accepts two input arguments and returns no result.",
    "explanation": "A `BiConsumer<T, U>` is a functional interface that takes two arguments (of types `T` and `U`) and performs an action, without returning any value. It's often used in `forEach` or `Map.forEach` operations.",
    "options": [
      "An interface that consumes two streams and produces one.",
      "An interface that returns two results.",
      "An interface that represents an operation that accepts two input arguments and returns no result.",
      "An interface for combining two functions."
    ]
  },
  {
    "questionText": "What is the significance of the `transient` keyword in Java Serialization?",
    "correctAnswer": "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
    "explanation": "If a field is declared `transient`, its value will not be included in the serialized output. Upon deserialization, that field will revert to its default value (e.g., `null` for objects, `0` for numeric types). This is useful for sensitive data (passwords) or data that can be recomputed.",
    "options": [
      "It indicates that a field must be initialized at compile time.",
      "It makes a field volatile for thread safety.",
      "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
      "It allows a field to be modified from different threads."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the difference between `Stream.forEach()` and `Collection.forEach()`?",
    "correctAnswer": "`Stream.forEach()` is a terminal stream operation that may execute in parallel and does not guarantee encounter order. `Collection.forEach()` is a default method on `Iterable` that iterates sequentially and preserves encounter order.",
    "explanation": "`Stream.forEach()` is part of the `Stream` API, designed for processing data in a pipeline, and its execution order for parallel streams is not guaranteed. `Collection.forEach()` (inherited from `Iterable`) is a more convenient way to iterate over collections sequentially, similar to an enhanced `for` loop.",
    "options": [
      "`Stream.forEach()` can modify the underlying collection; `Collection.forEach()` cannot.",
      "`Collection.forEach()` is faster for large datasets.",
      "`Stream.forEach()` is a terminal stream operation that may execute in parallel and does not guarantee encounter order. `Collection.forEach()` is a default method on `Iterable` that iterates sequentially and preserves encounter order.",
      "There is no functional difference; they are aliases."
    ]
  },
  {
    "questionText": "What is the purpose of `WeakHashMap` and how does it affect garbage collection?",
    "correctAnswer": "Keys in a `WeakHashMap` are held using weak references. If a key object is not strongly referenced elsewhere, its entry in the map can be garbage collected, preventing memory leaks for temporary keys.",
    "explanation": "`WeakHashMap` is used when you want the map to automatically discard entries once their keys are no longer strongly referenced by other parts of the application. This helps in managing memory for caches where entries should expire if their keys are no longer in use.",
    "options": [
      "It prevents garbage collection of its keys.",
      "It provides a synchronized version of `HashMap`.",
      "Keys in a `WeakHashMap` are held using weak references. If a key object is not strongly referenced elsewhere, its entry in the map can be garbage collected, preventing memory leaks for temporary keys.",
      "Values in a `WeakHashMap` are automatically removed after a timeout."
    ]
  },
  {
    "questionText": "What is the significance of the `transient` keyword in Java Serialization?",
    "correctAnswer": "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
    "explanation": "If a field is declared `transient`, its value will not be included in the serialized output. Upon deserialization, that field will revert to its default value (e.g., `null` for objects, `0` for numeric types). This is useful for sensitive data (passwords) or data that can be recomputed.",
    "options": [
      "It indicates that a field must be initialized at compile time.",
      "It makes a field volatile for thread safety.",
      "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
      "It allows a field to be modified from different threads."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is `ThreadLocalRandom` (Java 7+), and why is it preferred over `Random` in multi-threaded contexts?",
    "correctAnswer": "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
    "explanation": "Instances of `java.util.Random` are thread-safe but may suffer from contention in highly concurrent environments because multiple threads try to update the same seed. `ThreadLocalRandom` avoids this by giving each thread its own `Random` instance, eliminating contention and improving performance.",
    "options": [
      "It generates truly random numbers.",
      "It is a legacy class for backward compatibility.",
      "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
      "It uses a larger seed for more randomness."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the concept of `Bi-directional Relationship` in JPA/Hibernate, and what is the common pitfall with it?",
    "correctAnswer": "When two entities reference each other, establishing a link in both directions. The common pitfall is managing both sides of the relationship consistently to avoid infinite loops or synchronization issues.",
    "explanation": "For example, a `User` has `List<Address>` and `Address` has a `User`. The pitfall lies in ensuring that when you add an address to a user, you also set the user on the address and vice-versa, especially during persistence to avoid orphaned records or unintended behavior like infinite loops in `toString()` or `equals()/hashCode()`.",
    "options": [
      "When an entity can be accessed from two different tables.",
      "When a single entity class has two primary keys.",
      "When two entities reference each other, establishing a link in both directions. The common pitfall is managing both sides of the relationship consistently to avoid infinite loops or synchronization issues.",
      "When an entity can be saved to two different databases."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the concept of **`BiConsumer`** in Java 8's functional interfaces?",
    "correctAnswer": "An interface that represents an operation that accepts two input arguments and returns no result.",
    "explanation": "A `BiConsumer<T, U>` is a functional interface that takes two arguments (of types `T` and `U`) and performs an action, without returning any value. It's often used in `forEach` or `Map.forEach` operations.",
    "options": [
      "An interface that consumes two streams and produces one.",
      "An interface that returns two results.",
      "An interface that represents an operation that accepts two input arguments and returns no result.",
      "An interface for combining two functions."
    ]
  },
  {
    "questionText": "What is the significance of the `transient` keyword in Java Serialization?",
    "correctAnswer": "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
    "explanation": "If a field is declared `transient`, its value will not be included in the serialized output. Upon deserialization, that field will revert to its default value (e.g., `null` for objects, `0` for numeric types). This is useful for sensitive data (passwords) or data that can be recomputed.",
    "options": [
      "It indicates that a field must be initialized at compile time.",
      "It makes a field volatile for thread safety.",
      "It marks a field such that it will not be serialized when an object is written to a persistent stream.",
      "It allows a field to be modified from different threads."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of **`StampedLock`'s optimistic read lock**?",
    "correctAnswer": "It's a non-blocking read operation that doesn't acquire a lock. It returns a 'stamp' that must be validated later to ensure no write operation occurred during the read.",
    "explanation": "An optimistic read doesn't block writers, making it very performant for read-heavy scenarios. You get a `stamp` before reading, read the data, then `validate()` the stamp. If `validate()` returns `false`, a write occurred, and you must acquire a pessimistic read lock or retry the optimistic read.",
    "options": [
      "It's a read lock that can be acquired by only one reader at a time.",
      "It's a read lock that prioritizes writers.",
      "It's a non-blocking read operation that doesn't acquire a lock. It returns a 'stamp' that must be validated later to ensure no write operation occurred during the read.",
      "It allows both reading and writing concurrently without any locking."
    ]
  },
  {
    "questionText": "What is the concept of `Bi-directional Relationship` in JPA/Hibernate, and what is the common pitfall with it?",
    "correctAnswer": "When two entities reference each other, establishing a link in both directions. The common pitfall is managing both sides of the relationship consistently to avoid infinite loops or synchronization issues.",
    "explanation": "For example, a `User` has `List<Address>` and `Address` has a `User`. The pitfall lies in ensuring that when you add an address to a user, you also set the user on the address and vice-versa, especially during persistence to avoid orphaned records or unintended behavior like infinite loops in `toString()` or `equals()/hashCode()`.",
    "options": [
      "When an entity can be accessed from two different tables.",
      "When a single entity class has two primary keys.",
      "When two entities reference each other, establishing a link in both directions. The common pitfall is managing both sides of the relationship consistently to avoid infinite loops or synchronization issues.",
      "When an entity can be saved to two different databases."
    ]
  },
  {
    "questionText": "What is `ThreadLocalRandom` (Java 7+), and why is it preferred over `Random` in multi-threaded contexts?",
    "correctAnswer": "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
    "explanation": "Instances of `java.util.Random` are thread-safe but may suffer from contention in highly concurrent environments because multiple threads try to update the same seed. `ThreadLocalRandom` avoids this by giving each thread its own `Random` instance, eliminating contention and improving performance.",
    "options": [
      "It generates truly random numbers.",
      "It is a legacy class for backward compatibility.",
      "`ThreadLocalRandom` provides a thread-safe and contention-free pseudo-random number generator, as each thread gets its own instance, avoiding synchronization overhead.",
      "It uses a larger seed for more randomness."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the concept of **`BiConsumer`** in Java 8's functional interfaces?",
    "correctAnswer": "An interface that represents an operation that accepts two input arguments and returns no result.",
    "explanation": "A `BiConsumer<T, U>` is a functional interface that takes two arguments (of types `T` and `U`) and performs an action, without returning any value. It's often used in `forEach` or `Map.forEach` operations.",
    "options": [
      "An interface that consumes two streams and produces one.",
      "An interface that returns two results.",
      "An interface that represents an operation that accepts two input arguments and returns no result.",
      "An interface for combining two functions."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  },
  {
    "questionText": "What is the purpose of `Thread.onSpinWait()` (Java 9+)?",
    "correctAnswer": "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
    "explanation": "`onSpinWait()` is a low-level intrinsic that can be used in tight loops where a thread is actively waiting for a condition without blocking. It tells the processor that the thread is spinning, which can prevent pipeline stalls and improve efficiency on some architectures by, for example, executing a `PAUSE` instruction.",
    "options": [
      "To force a thread to sleep for a short duration.",
      "To prevent a thread from ever entering a waiting state.",
      "It's a hint to the JVM or CPU that the current thread is executing a busy-wait loop, potentially allowing for power-saving or performance optimizations (e.g., `PAUSE` instruction on x86).",
      "To make a thread release its current lock."
    ]
  }]